{"meta":{"title":"Hzebin 黄泽彬的博客","subtitle":null,"description":null,"author":"Huang Zebin","url":"http://github.com/hzebin"},"pages":[{"title":"Hzebin  |  404 Error","date":"2019-01-27T02:40:04.478Z","updated":"2019-01-27T02:40:04.478Z","comments":true,"path":"404.html","permalink":"http://github.com/hzebin/404.html","excerpt":"","text":""},{"title":"","date":"2019-01-24T02:41:26.161Z","updated":"2019-01-24T02:41:26.161Z","comments":false,"path":"categories/index.html","permalink":"http://github.com/hzebin/categories/index.html","excerpt":"","text":""},{"title":"成长足迹","date":"2019-01-27T06:36:40.878Z","updated":"2019-01-27T06:36:40.878Z","comments":true,"path":"footprint/index.html","permalink":"http://github.com/hzebin/footprint/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-26T12:18:35.502Z","updated":"2019-01-26T12:18:35.502Z","comments":true,"path":"shuatiben/index.html","permalink":"http://github.com/hzebin/shuatiben/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-01-27T02:37:32.627Z","updated":"2019-01-27T02:37:32.627Z","comments":true,"path":"liuyan/index.html","permalink":"http://github.com/hzebin/liuyan/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-24T07:19:39.661Z","updated":"2019-01-24T07:19:39.661Z","comments":false,"path":"tags/index.html","permalink":"http://github.com/hzebin/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-02-19T13:31:02.015Z","updated":"2019-02-19T13:31:02.015Z","comments":true,"path":"links/index.html","permalink":"http://github.com/hzebin/links/index.html","excerpt":"","text":"在这里添加一些有趣、优秀的友链。本站刚搭建完成，还有很多不足之处，欢迎各位互换友链，请在下方留言。 友链要求：√原创优先&nbsp;&nbsp;&nbsp;√技术优先×经常宕机&nbsp;&nbsp;&nbsp;×不合法规&nbsp;&nbsp;&nbsp;×擦边球站&nbsp;&nbsp;&nbsp;×红标报毒 名称 网页链接 程序员在线工具 http://www.ofmonkey.com/ 疆飞.NET https://www.jiangfei.net/ Sanshi http://www.sanshi30.cn/ 一稚杨的博客 https://huangwenyang.cn/main/ 爱生活爱技术 http://www.xioaxin12.xyz/ 燕十三 https://www.yanshisan.cn/Blog/Index"},{"title":"test area","date":"2019-02-19T13:24:32.107Z","updated":"2019-02-19T13:24:32.107Z","comments":true,"path":"test/index.html","permalink":"http://github.com/hzebin/test/index.html","excerpt":"","text":"水果 价格 数量 香蕉 $1 苹果 $1 6 草莓 $1 7"}],"posts":[{"title":"Vue","slug":"vue","date":"2020-01-26T02:40:24.652Z","updated":"2020-01-30T13:57:47.288Z","comments":true,"path":"2020/01/26/vue/","link":"","permalink":"http://github.com/hzebin/2020/01/26/vue/","excerpt":"","text":"6-SCJ -》 CWL认识VueVue(读音似view) Vue是一个渐进式的框架，响应式 Vue有很多特点和Web卡法中常见的高级功能： 解耦视图和数据 可复用的组件 前端路由技术 状态管理 虚拟DOM 引入Vue的CDN12345&lt;!--开发环境版本，包含了有帮助的命令行警告--&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!--生产环境版本，优化了尺寸和速度--&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 初步使用12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', //绑定元素 data: &#123; //设置数据 message: 'Hello 黄泽彬', name: '黄泽彬' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环展示列表数据 v-for123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in movies\"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; name: 'HuangZebin', movies: ['速度与激情', '西游记', '垃圾'] &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 绑定事件 v-on123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; 当前技术：&#123;&#123;counter&#125;&#125; &lt;button v-on:click=\"++counter\"&gt;+&lt;/button&gt; &lt;button v-on:click=\"--counter\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"app\"&gt; 当前技术：&#123;&#123;counter&#125;&#125; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"sub\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; add: function() &#123; ++this.counter; &#125;, sub: function() &#123; --this.counter; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; MVVMMVVM (Model View View Model) Vue实例传入的options123456789101112131415el 类型：string | HTMLElement 作用：决定之后Vue实例会管理哪一个DOMdata 类型：Object | Function【组件当中data必须是一个函数】 作用：Vue实例对应的数据对象methods 类型：&#123; [key: string]: Function &#125; 作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用filters 过滤器components 组件props 属性 Mustache语法通过Mustache语法（双大括号），可以将data中的文本数据插入到HTML中 1234567891011121314151617181920212223&lt;body&gt; &lt;!--Mustache语法不仅可以写变量，也可以写简单的表达式--&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;firstName + ' ' + lastName&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;counter * 2&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello', firstName: '黄', lastName: '泽彬', counter: 1 &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-once语法v-once指令不需要跟任何表达式，该指令表示元素和组件只渲染一次，不会随着数据的改变而改变 1234567891011121314151617&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h1 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;!--在控制台修改message，虽是响应式的，但v-once那一句不会改变--&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '黄泽彬' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-html语法v-html可以将数据解析为htm格式 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;url&#125;&#125;&lt;/h1&gt; &lt;!--解析为html--&gt; &lt;h1 v-html=\"url\"&gt;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; url: '&lt;a href=\"http://hzebin.cn\"&gt;黄泽彬个人主页&lt;/a&gt;' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-text语法v-text作用和Mustache比较相似：都是用于将数据显示在界面中，v-text通常情况下，接收一个string类型 （不够灵活，后面的数据会被覆盖，没有双大括号好用） 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;456&lt;/h1&gt; &lt;!--456会被覆盖--&gt; &lt;h1 v-text=\"message\"&gt;456&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '123' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-pre指令v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;!--显示&#123;&#123;message&#125;&#125;--&gt; &lt;h1 v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '黄泽彬' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; [??] 13 v-cloakv-bind指令v-bind作用是动态绑定属性，缩写为【:】 12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--将数据动态绑定给属性--&gt; &lt;img v-bind:src=\"imageUrl\" alt=\"\"/&gt; &lt;a v-bind:href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=\"imageUrl\" alt=\"\"/&gt; &lt;a :href=\"aHref\"&gt;百度一下(语法糖)&lt;/a&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; imageUrl: 'https://i0.hdslb.com/bfs/archive/a85460cd16061187d1eb88ef849008ac7e8f1f3a.jpg@336w_190h.webp', aHref: 'http://baidu.com' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-bind动态绑定class—-对象语法 123456789101112131415161718192021222324252627282930313233343536373839&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1 class=\"active\"&gt;你好&lt;/h1&gt; &lt;!--&lt;h1 :class=\"&#123;key1: value1, key2: value2&#125;\"&gt;&lt;/h1&gt;--&gt; &lt;!--&lt;h1 :class=\"&#123;类名: boolean, 类名: value2&#125;\"&gt;&lt;/h1&gt;--&gt; &lt;!--class的数据会合并--&gt; &lt;h1 class=\"t1\" :class=\"&#123;active: isActive, line: isLine&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '你好啊', isActive: true, isLine: true &#125;, methods: &#123; btnClick: function() &#123; this.isActive = !this.isActive; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-bind动态绑定class—-数组语法 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 当成字符串解析--&gt; &lt;h1 class=\"title\" :class=\"['aa', 'bbb']\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;!-- 没有单引号为变量--&gt; &lt;h1 :class=\"['a', c]\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;!--通过方法返回--&gt; &lt;h1 :class=\"getClass()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello', c: 'ccc' &#125;, methods: &#123; getClass: function() &#123; return [this.c]; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-bind动态绑定style（一） 我们可以用v-bind:style来绑定一些CSS内联样式 在写CSS属性名时，比如font-size 我们可以使用驼峰式（camelCase）fontSize 或短横线分割（Kebab-case，记得用单引号括起来）’font-size’ 绑定class有两种方式： 对象语法（属性值加了单引号为字符串，否则为变量） 数组语法 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;!--对象属性--&gt; &lt;div id=\"app\"&gt; &lt;!--&lt;h1 :style=\"&#123;key属性名: value属性值&#125;\"&gt;&lt;/h1&gt;--&gt; &lt;h1 :style=\"\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;!--对象语法--&gt; &lt;h1 :style=\"&#123;fontSize: '50px'&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h1 :style=\"&#123;fontSize: finalSize&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;!--推荐--&gt; &lt;h1 :style=\"getStyle()\"&gt;&#123;&#123;message&#125;&#125;123&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello World', finalSize: '100px' &#125;, methods: &#123; getStyle: function() &#123; return &#123;fontSize: this.finalSize&#125;; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819&lt;body&gt; &lt;!--数组属性--&gt; &lt;div id=\"app\"&gt; &lt;h1 :style=\"[baseStyle1, baseStyle2]\"&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: 'hzb', baseStyle1: &#123;fontSize: '100px'&#125;, //对象，键值对 baseStyle2: &#123;backgroundColor: 'red'&#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 计算属性 computedcomputed: {} 可以对需要的数据进行转化之后显示，或需要将多个数据结合起来显示。(只执行一次，有缓存)（相当于一个属性，用名词命名） 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;firstName + ' ' + lastName&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h1&gt; &lt;!--计算属性，是一个属性，不用()--&gt; &lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; firstName: 'Huang', lastName: 'Zebin' &#125;, methods: &#123; getFullName: function() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125;, computed: &#123; //计算属性 fullName: function() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;总价为&#123;&#123;totalPrice&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; books: [ &#123;id: '101', name: '操作系统', price: 100&#125;, &#123;id: '102', name: 'Linux操作系统', price: 150&#125;, &#123;id: '103', name: '高等数学', price: 200&#125; ] &#125;, computed: &#123; totalPrice: function() &#123; let total = 0; for (let i = 0; i &lt; this.books.length; ++i) &#123; total += this.books[i].price; &#125; return total; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 完整写计算属性的get/set计算属性一般没有set方法，为只读属性 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; firstName: 'Huang', lastName: 'Zebin' &#125;, computed: &#123; fullName: &#123; set: function(newValue) &#123; //在控制台改变fullName变量的值试试 console.log(\"==\" + newValue + \"==\"); const names = newValue.split(' '); //空格隔开，返回数组 this.firstName = names[0]; this.lastName = names[1]; &#125;, get: function() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 计算属性和methods的对比methods方法每次调用都会重新计算；而computed只要结果不变就只执行一次，它有缓存，推荐computed 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--1.直接拼接，语言过于繁琐--&gt; &lt;h1&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h1&gt; &lt;!--2.通过methods方法--&gt; &lt;h1&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h1&gt; &lt;!--3.通过计算属性,有缓存，只执行一次--&gt; &lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; firstName: 'Huang', lastName: '泽彬' &#125;, methods: &#123; getFullName: function() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125;, computed: &#123; fullName: function() &#123; return this.firstName + ' ' + this.lastName; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ES6补充事实上var是JS的一个设计上的错误，let关键字是可以更完美代替var。let有块级作用域，而var在块外任然可以访问会有问题 const关键字：用const修饰的标识符不会被再次赋值，保证了数据的安全性，但是申明的时候需要初始化一个值。 1234const1. 一旦给const修饰的标识符被赋之后，不能修改2. 在使用const定义标识符，必须进行赋值3. 常量的含义是指向的对象不能修改（内存地址不能改），但是可以改变对象的内部属性 【建议】在ES6开发中，优先使用const，只有需要改变某一个标识符的时候才使用let 增强写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;script&gt; // const obj = &#123;&#125; //这个大括号就是字面量 //字面量的一般写法 // const app = &#123; // name: 'Huang', // age: 20, // run: function() &#123; // console.log(\"我在奔跑\"); // &#125;, // eat: function() &#123; // console.log(\"我在吃东西\"); // &#125; // &#125; //1. 属性的增强写法 const name = 'Huang Zebin'; const age = 20; const height = 1.75; //ES5的写法 // const obj = &#123; // name: name, // age: age, // height: height // &#125; // console.log(obj); //ES6的写法，可以直接写标识符进去 const obj = &#123; name, age, height &#125; console.log(obj); //============================== //2. 函数的增强写法 //ES5写法 // const obj2 = &#123; // eat: function() &#123; // // &#125;, // run: function() &#123; // // &#125; // &#125; //ES6写法 const obj2 = &#123; run() &#123; &#125;, eat() &#123; &#125; &#125; //============================== &lt;/script&gt;&lt;/body&gt; 123456ES5 &apos;&apos;单引号 &quot;&quot;双引号ES6 ``【可以换行】上面三种方式都可以申明字符串 v-on的基本使用和语法糖123指令：v-on作用：绑定事件监听器缩写：@ 12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;counter&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"--counter\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; add() &#123; ++this.counter; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-on方法含有参数当通过methods中定义方法，以供@click调用时，需要注意参数问题： 如果该方法不需要额外参数，那么方法后的()可以不添加 但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去。 如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--事件调用的方法没有参数--&gt; &lt;button @click=\"btn1Click\"&gt;按钮1&lt;/button&gt; &lt;button @click=\"btn1Click()\"&gt;按钮1&lt;/button&gt; &lt;!--含有一个参数--&gt; &lt;button @click=\"btn2Click(888)\"&gt;按钮2&lt;/button&gt; &lt;button @click=\"btn2Click()\"&gt;按钮2&lt;/button&gt; &lt;!--undefine--&gt; &lt;button @click=\"btn2Click\"&gt;按钮2&lt;/button&gt; &lt;!--event事件--&gt; &lt;!--含有event参数，也有其他参数--&gt; &lt;button @click=\"btn3Click($event, 1, 2, m1, 'm1')\"&gt;按钮3&lt;/button&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; m1: '11111' &#125;, methods: &#123; btn1Click() &#123; console.log(\"123\", \"----\"); &#125;, btn2Click(a) &#123; //如果调用的方法有(),没有传入参数值，则为undefine //如果没有()则为event事件 console.log(a); &#125;, btn3Click(event, a, b, c, d) &#123; console.log(event, a, b, c, d); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-on的修饰符12345.stop修饰符，可以组织冒泡现象.prevent修饰符，阻止默认行为；例如提交表单，会阻止浏览器自动提交表单，转到自己的方法.&#123;keyCode | keyAlias&#125;监听键盘的按键.native监听组件根元素的原生事件.once只触发一次回调 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--会冒泡现象，如果点击了按钮1，div1Click也会触发--&gt; &lt;div @click=\"div1Click\"&gt; aaa &lt;button @click=\"btn1Click\"&gt;按钮1&lt;/button&gt; &lt;/div&gt; &lt;hr/&gt; &lt;!--.stop修饰符，阻止了冒泡的现象--&gt; &lt;div @click=\"div1Click\"&gt; aaa &lt;button @click.stop=\"btn1Click\"&gt;按钮1&lt;/button&gt; &lt;/div&gt; &lt;hr/&gt; &lt;!--.prevent修饰符，阻止默认事件--&gt; &lt;form action=\"baidu\"&gt; &lt;input type=\"submit\" value=\"提交\" @click.prevent=\"subClick\"/&gt; &lt;/form&gt; &lt;!--监听键盘的某一个按键--&gt; &lt;input type=\"text\" @keyup=\"keyClick\"/&gt; &lt;hr/&gt; &lt;!--监听回车按键被按--&gt; &lt;input type=\"text\" @keyup.enter=\"enterClick\"/&gt; &lt;!--.once修饰符，只执行一次--&gt; &lt;button @click.once=\"btn2Click\"&gt;按钮2&lt;/button&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; btn1Click() &#123; console.log(\"btn1Click\"); &#125;, div1Click() &#123; console.log(\"div1Click\"); &#125;, subClick() &#123; console.log(\"subClick\"); &#125;, keyClick() &#123; console.log(\"keyClick\"); &#125;, enterClick() &#123; console.log(\"回车\"); &#125;, btn2Click() &#123; console.log(\"btn2Click\"); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-if和v-else-if和v-else的使用如果条件很多，推荐使用计算属性 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1 v-if=\"score &gt;= 90\"&gt;优秀&lt;/h1&gt; &lt;h1 v-else-if=\"score &gt;= 80\"&gt;良好&lt;/h1&gt; &lt;h1 v-else-if=\"score &gt;= 60\"&gt;及格&lt;/h1&gt; &lt;h1 v-else&gt;不及格&lt;/h1&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; score: 92 &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-showv-show指令决定一个元素是否渲染 v-if与v-show的比较： v-if当条件为false时，不会有对应的元素在DOM v-show当条件为false时，仅仅是将元素的display属性设置为none而已 怎么选择： 当需要在显示和隐藏之间切面很频繁是，使用v-show 当只有一次切换时，使用v-if v-for遍历数组和对象1有下标值，先item后index 遍历数组 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--没有下标值--&gt; &lt;ul&gt; &lt;li v-for=\"item in names\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--有下标值，先item后index--&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in names\"&gt;&#123;&#123;index + 1&#125;&#125; &#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; names: ['黄泽彬', '熊君', '陈文略'] &#125;, methods: &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 遍历对象 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--没有使用循环--&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;info.name&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;info.age&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;info.height&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--(value) 值--&gt; &lt;ul&gt; &lt;li v-for=\"value in info\"&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--(value, key) 值 键--&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in info\"&gt;&#123;&#123;value&#125;&#125;--&#123;&#123;key&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--(value, key, index) 值 键 序号--&gt; &lt;ul&gt; &lt;li v-for=\"(value, key, index) in info\"&gt;&#123;&#123;value&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; info: &#123; name: 'HuangZebin', age: 20, height: 1.75 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 理解v-for绑定和非绑定key的区别推荐在使用v-for的时候，给对应的元素或组件添加:key属性，这个:key值需要能与值对应(唯一性)，比如value，但index可能会改变 为什么要key属性：Vue的虚拟DOM有关系，加key不让它复用原来的代码 数组中的哪些方法是响应式的因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。 123456789101112131415161718192021哪些方法是响应式的：push()在数组的尾部添加元素【可以一次添加多个元素，逗号分隔】pop()删除数组尾部的元素shift()删除数组头部的元素unshift()在数组头部添加元素【可以一次添加多个元素，逗号分隔】splice() 删除元素： splice(start, n) 从start下标开始，删除n个元素，如果省略n则后面全删 替换元素： splice(start, n, ...value[])从start删n个，之后添加元素在那个位置 插入元素： splice(start, 0, ...value[])在start位置开始插入元素sort()排序，默认从小到大reverse() 数组反转Vue.set(要修改的对象, 索引值, 修改后的值) 例如Vue.set(this.arr, 0, 'bb');=============================通过索引修改元素不是响应式的============================= 表单绑定v-modelVue中使用v-model指令来实现表单元素和数据的双向绑定 原理： v-bind绑定一个value属性 v-on指令给当前元素绑定input事件 等价于 123&lt;input type=\"text\" v-model=\"message\"/&gt;↑↓&lt;input type=\"text\" :value=\"message\" :input=\"message = $event.target.value\"/&gt; 12345678910111213141516&lt;body&gt;&lt;div id=\"app\"&gt; 双向绑定 &lt;input type=\"text\" v-model=\"message\"/&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: 'Huang Zebin' &#125; &#125;)&lt;/script&gt;&lt;/body&gt; v-model与radio(单选框)12345678910111213141516171819202122&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!-- v-model绑定了同一个sex之后，可以省略name--&gt; &lt;label for=\"male\"&gt; &lt;!--label的for可以在用户选中文字之后，按钮会自动选中--&gt; &lt;input type=\"radio\" id=\"male\" name=\"sex\" value=\"男\" v-model=\"sex\"/&gt;男 &lt;/label&gt; &lt;label for=\"female\"&gt; &lt;input type=\"radio\" id=\"female\" name=\"sex\" value=\"女\" v-model=\"sex\"/&gt;女 &lt;/label&gt; &lt;h1&gt;你选择的性别是：&#123;&#123;sex&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; sex: '' //可以初始化 男-女 &#125; &#125;)&lt;/script&gt;&lt;/body&gt; v-model与checkbox(复选框)123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!--checkbox单选框--&gt; &lt;label for=\"agree\"&gt; &lt;input type=\"checkbox\" id=\"agree\" v-model=\"isAgree\"/&gt;同意协议 &lt;/label&gt; &lt;br/&gt; &lt;button :disabled=\"!isAgree\"&gt;下一步&lt;/button&gt; &lt;hr/&gt; &lt;!--checkbox多选框--&gt; &lt;input type=\"checkbox\" value=\"足球\" v-model=\"hobbies\"/&gt;足球 &lt;input type=\"checkbox\" value=\"台球\" v-model=\"hobbies\"/&gt;台球 &lt;input type=\"checkbox\" value=\"乒乓球\" v-model=\"hobbies\"/&gt;乒乓球 &lt;input type=\"checkbox\" value=\"蓝球\" v-model=\"hobbies\"/&gt;篮球 &lt;h1&gt;选择的爱好为：&#123;&#123;hobbies&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; isAgree: false, hobbies: [] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 单选框对应boolean，多选框对应数组 v-model和select结合使用1234567891011121314151617181920212223242526272829303132&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!--选择一个--&gt; &lt;select v-model=\"fruit\"&gt; &lt;option value=\"苹果\"&gt;苹果&lt;/option&gt; &lt;option value=\"香蕉\"&gt;香蕉&lt;/option&gt; &lt;option value=\"葡萄\"&gt;葡萄&lt;/option&gt; &lt;option value=\"桃子\"&gt;桃子&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;选了什么水果：&#123;&#123;fruit&#125;&#125;&lt;/h1&gt; &lt;!--选择多个--&gt; &lt;select v-model=\"fruits\" multiple&gt; &lt;option value=\"苹果\"&gt;苹果&lt;/option&gt; &lt;option value=\"香蕉\"&gt;香蕉&lt;/option&gt; &lt;option value=\"葡萄\"&gt;葡萄&lt;/option&gt; &lt;option value=\"桃子\"&gt;桃子&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;选了什么水果：&#123;&#123;fruits&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; fruit: '香蕉', fruits: [] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 值绑定123456789101112131415161718192021&lt;body&gt;&lt;div id=\"app\"&gt; &lt;label v-for=\"item in starts\" :for=\"item\"&gt; &lt;input type=\"checkbox\" :id=\"item\" :value=\"item\" v-model=\"selectStarts\"/&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt; &lt;h1&gt;选择的明星为：&#123;&#123;selectStarts&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; //已选择 selectStarts: [], //原数据 starts: ['赵丽颖', '吴亦凡', '邓超', '李现'] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; v-model修饰符1234567891011lazy修饰符 1. 默认情况下，v-model默认是在input事件中同步输入框的数据的 2. 也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变 3. lazy修饰符可以让数据在失去焦点或者回车时才会更新number修饰符 1. 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当作【字符串】类型进行处理 2. 但是如果我们希望处理的数字类型，那么最好直接将内容当做数字处理 3. number修饰符可以让在输入框中输入的内容自动转成数字类型trim修饰符 1. 如果输入的内容首尾有很多空格，通常我们希望将其去除 2. trim修饰符可以过滤内容左右边的空格 12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!-- lazy修饰符 --&gt; &lt;input type=\"text\" v-model.lazy=\"message\"/&gt; &#123;&#123;message&#125;&#125; &lt;hr/&gt; &lt;!-- number修饰符 --&gt; &lt;input type=\"number\" v-model.number=\"age\"/&gt; 类型&#123;&#123;typeof age&#125;&#125; &lt;hr/&gt; &lt;!-- trim修饰符 --&gt; &lt;input type=\"text\" v-model.trim=\"name\"/&gt; name=&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '123', age: 23, name: '' &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 组件化初步认识 我们将一个完整的页面分成很多个组件 每个组件都用于实现页面的一个功能 而每一个组件又可以进行细分 组件化是Vue.js中的重要思想 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用 任何的应用都会被抽象成一棵组件树 组件化思想的应用： 有了组件化思想，我们在之后的开发中就要充分利用它 进可能地将页面拆分成一个个小地、可复用地组件 这样让我们的代码更加方便组织和管理，并且扩展性也更强 注册组件的基本步骤： 创建组件构造器Vue.extend() 调用Vue.extend()创建的是一个组件构造器 通常在创建组件构造器是，传入template代表我们自定义组件的模板 该模板就是在使用到组件的地方，要显示的HTML代码 注册组件Vue.component() 调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称 需要传递两个参数：注册组件的标签名、组件构造器 使用组件 组件必须挂载到某个Vue实例下，否则它不会生效 123456789101112131415161718192021222324252627&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!--3.使用--&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; //1.创建组件构造器对象 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h6&gt;我是标题&lt;/h6&gt; &lt;p&gt;第一行内容&lt;/p&gt; &lt;p&gt;第二行内容&lt;/p&gt; &lt;/div&gt;` &#125;) //2.注册组件 【这里是全局组件】 Vue.component('my-cpn', cpnC); const app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/body&gt; 【！写组件的时候，要写在内 ！】 全局组件和局部组件在开发中一般只有一个new Vue实例 全局组件：可以在多个Vue的实例下使用 局部组件：在new Vue里面定义的 components: {标签名： 组件名} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn2&gt;&lt;/cpn2&gt; &lt;cpn1&gt;&lt;/cpn1&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;cpn2&gt;&lt;/cpn2&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; //全局组件 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;我的标题&lt;/h1&gt; &lt;p&gt;哈哈哈这一行是废的&lt;/p&gt; &lt;/div&gt; ` &#125;) Vue.component('cpn1', cpnC);&lt;/script&gt;&lt;script&gt; //局部组件 const cpnD = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;局部的组件模板&lt;/h2&gt; &lt;/div&gt; ` &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app' &#125;) const app2 = new Vue(&#123; el: '#app2', //下面定义局部组件 components: &#123; cpn2: cpnD &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 父组件和子组件的区别12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; //子组件 const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;组件1&lt;/h1&gt; &lt;/div&gt; ` &#125;) //父组件 const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;组件2&lt;/h1&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt; `, //申明使用的子组件 components: &#123; cpn1: cpnC1 &#125; &#125;) //root组件 const app = new Vue(&#123; el: '#app', //申明使用的父组件 components: &#123; cpn: cpnC2 &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 组件的语法糖写法【组件标签名用小写】查找组件时，先在自己内部找components，如果没有则找全局的，所以全局的组件可以不用在new Vue实例里面的components注册 【组件的名字用小写的，因为HTML解析是不区分大小写，用全小写来查找组件标签！！】 12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;div id=\"app\"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn2&gt;&lt;/my-cpn2&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn', &#123; template: ` &lt;div&gt; &lt;h1&gt;语法糖-全局组件&lt;/h1&gt; &lt;/div&gt; ` &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', components: &#123; 'my-cpn2': &#123; template: ` &lt;div&gt; &lt;h1&gt;语法糖--局部组件&lt;/h1&gt; &lt;/div&gt; ` &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 组件模板抽离的写法123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt;&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt; &lt;my-cpn2&gt;&lt;/my-cpn2&gt;&lt;/div&gt;&lt;!--组件分离的模板 全局变量 方式1--&gt;&lt;script type=\"text/x-template\" id=\"my-cpn1\"&gt; &lt;div&gt; &lt;h1&gt;组件模板分离-全局变量 方式1&lt;/h1&gt; &lt;/div&gt;&lt;/script&gt;&lt;!--组件分离的模板 全局变量 方式2--&gt;&lt;template id=\"my-cpn2\"&gt; &lt;div&gt; &lt;h1&gt;组件模板分离-全局变量 方式2&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn1', &#123; template: '#my-cpn1' &#125;)&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn2', &#123; template: '#my-cpn2' &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/body&gt; 组件data必须是函数组件里面访问不了实例里的data数据 组件自己的数据存放在哪里呢： 组件对象也有一个data属性（也有methods等属性） 只是这个data属性必须是一个函数 而且这个函数返回一个对象，对象内部保存着数据 如果组件里的data不是函数，那么组件复用时，数据是共享的 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt;&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;/div&gt;&lt;template id=\"my-cpn1\"&gt; &lt;div&gt; &lt;h1&gt;当前计数为：&#123;&#123;counter&#125;&#125;&lt;/h1&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn1', &#123; template: '#my-cpn1', data() &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment() &#123; ++this.counter; &#125;, decrement() &#123; --this.counter; &#125; &#125; &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/body&gt; 父子组件的通信在开发中，往往一些数据确实需要从上层（root）传递到下层（小组件）。 比如在一个页面中，我们从服务器请求到了很多的数据 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。 这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件（父组件）将数据传递给小组件（子组件） 如何进行父子组件间的通信呢： 通过props向子组件传递数据 通过事件向父组件发送信息 props的值有两种方式： 一：字符串数组，数组中的字符串就是传递时的名称 二：对象，对象可以设置传递时的类型，也可以设置默认值等。可以对类型进行验证，验证支持的类型：String, Number, Boolean, Array, Object, Date, Function, Symbol; 如果有自定义构造函数时，验证也支持自定义的类型。还可以提供默认值，如果使用了模板标签而没有v-bind绑定属性的值的话，会使用默认值。还可以限制使用模板标签时是否必传值。 12345对象名： &#123; type: 类型, default: 默认值, required: true/false 如果为true时，使用模板标签必须赋值&#125; 12345678910111213141516171819202122232425262728293031323334353637【父组件-》子组件 方式1】&lt;body&gt;&lt;div id=\"app\"&gt; &lt;my-cpn :cmessage=\"message\" :cstarts=\"starts\"&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;template id=\"my-cpn\"&gt; &lt;div&gt; &lt;h1&gt;子组件&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=\"item in cstarts\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&#123;&#123;cmessage&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn', &#123; template: '#my-cpn', //下面这里是变量 props: ['cmessage', 'cstarts'] &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '收到', starts: ['邓超', '吴亦凡', '赵丽颖'] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960【父组件 -》 子组件 方式二】&lt;body&gt;&lt;div id=\"app\"&gt; &lt;my-cpn :cmessage=\"message\" :cstarts=\"starts\"&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;template id=\"my-cpn\"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=\"item in cstarts\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn', &#123; template: '#my-cpn', // props: ['cmessage', 'cstarts'] 方式一：数组 //方式二：对象 // props: &#123; // //可以限制类型 // cmessage: String, // cstarts: Array // &#125; props: &#123; cmessage: &#123; //类型 type: String, //默认值 default: 'aaa', //true时，使用模板必须要传值 required: true &#125;, cstarts: &#123; type: Array, //类型是对象或数组时，默认类型必须是函数 default() &#123; return []; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '明星展示', starts: ['吴亦凡', '赵丽颖', '邓超', '邓紫棋'] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152【子组件 -》 父组件 自定义事件$smit】&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!--接收子组件发射出来的信息--&gt;&lt;!--cpnClick的参数不用写，默认传递--&gt; &lt;my-cpn @categories-btn-click=\"cpnClick\"&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;template id=\"my-cpn\"&gt; &lt;div&gt; &lt;button v-for=\"item in categories\" @click=\"btnClick(item)\"&gt; &#123;&#123;item.name&#125;&#125; &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('my-cpn', &#123; template: '#my-cpn', data() &#123; return &#123; categories: [ &#123;id: '0', name: '热门推荐'&#125;, &#123;id: '1', name: '手机数码'&#125;, &#123;id: '2', name: '家用家电'&#125;, &#123;id: '3', name: '电脑办公'&#125; ] &#125; &#125;, methods: &#123; btnClick(item) &#123; //子组件 向 父组件 发射事件 //用-分隔！！ this.$emit('categories-btn-click', item, '测试'); &#125; &#125; &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', methods: &#123; cpnClick(item, a) &#123; console.log(item, '123', a) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 父访问子里面的东西–$children $refsthis.$children返回的是子组件数组 this.$refs返回对象类型，默认为空对象{}；需要在使用标签那里加ref=”” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt;&lt;div id=\"app\"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;template id=\"my-cpn\"&gt; &lt;div&gt; &lt;h1&gt;我是子组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', methods: &#123; btnClick() &#123; console.log(this.$children); //返回的是数组 // $children 需要下标值，不够灵活，如果在中间插新的组件，下标值会改变 // this.$children[0].showMessage(); // console.log(this.$children[0].name); for (let c of this.$children) &#123; c.showMessage(); console.log(c.name); &#125; &#125; &#125;, components: &#123; 'my-cpn': &#123; template: '#my-cpn', methods: &#123; showMessage() &#123; console.log('Hello, 我是子组件里的方法') &#125; &#125;, data() &#123; return &#123; name: '我是子组件的数据name' &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn ref=\"ccc\"&gt;&lt;/cpn&gt; &lt;cpn ref=\"bbb\"&gt;&lt;/cpn&gt; &lt;cpn ref=\"aaa\"&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h1&gt;我是一个组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', methods: &#123; btnClick() &#123; // this.$refs 默认为空对象&#123;&#125; console.log(this.$refs.aaa.showMessage()); &#125; &#125;, components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; name: '子组件的name' &#125; &#125;, methods: &#123; showMessage() &#123; console.log(\"子组件的方法\"); &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 子访问父里面的东西–$parent $root不推荐子访问父组件，这样子组件与父组件之间有耦合性，子组件不能独立 this.$parent访问父组件 this.$root访问根组件【直接访问到Vue实例】 12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h1&gt;我是子组件&lt;/h1&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '父组件message' &#125;, components: &#123; cpn: &#123; template: '#cpn', methods: &#123; btnClick() &#123; //访问父组件 this.$parent console.log(this.$parent.message); &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; slot插槽的基本使用组件的插槽： 组件的插槽也是为了让我们封装的组件更加具有扩展性 让使用者决定组件内部的一些内容到底展示什么 插槽的基本使用 插槽的默认值默认值写在这里 如果有多个值同时放入到一个插槽进行替换时，一起作为替换元素 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;!--插入插槽--&gt; &lt;span&gt;嘻嘻嘻&lt;/span&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;i&gt;我去跑步了&lt;/i&gt; &lt;i&gt;我去跑步了&lt;/i&gt; &lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h1&gt;我是组件&lt;/h1&gt; &lt;p&gt;哈哈哈哈哈哈&lt;/p&gt; &lt;!--插槽标签,标签里面写的是默认值，如果使用时有新的则将默认值覆盖--&gt; &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('cpn', &#123; template: '#cpn' &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/body&gt; slot具名插槽的使用1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn&gt; &lt;!--指定插槽--&gt; &lt;button slot=\"left\"&gt;返回&lt;/button&gt; &lt;span slot=\"right\"&gt;菜单&lt;/span&gt; &lt;span slot=\"center\"&gt; &lt;span&gt;aaa&lt;/span&gt; &lt;span&gt;bbb&lt;/span&gt; &lt;/span&gt; &lt;/cpn&gt; &lt;hr/&gt; &lt;cpn&gt;&lt;span slot=\"right\"&gt;菜单&lt;/span&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;!--给插槽起名字--&gt; &lt;slot name=\"left\"&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt; &lt;slot name=\"center\"&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt; &lt;slot name=\"right\"&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('cpn', &#123; template: '#cpn' &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/body&gt; 理解编译作用域的概念判断是哪里的变量，看在哪一个模板，而不是在标签的那个组件 父组件模板的所有东西都会在父级作用域内编译，子组件模板的所有东西都会在子级作用域内编译 父组件替换插槽的标签，但是内容有子组件来提供 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn v-show=\"isShow\"&gt;&lt;/cpn&gt; &lt;!--使用了new Vue实例的isShow变量--&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h1&gt;我是子组件,有两个isShow,看看是哪一个&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('cpn', &#123; template: '#cpn', data() &#123; return &#123; //这里有一个isShow变量 isShow: false &#125; &#125; &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; //这里有一个isShow变量 isShow: true &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 作用域插槽的使用如果父组件对子组件展示的内容不满意，想以另外一种方式进行展示，就可以用到作用域插槽。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt;&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;!--目的是获取插槽的数据--&gt; &lt;template slot-scope=\"s\"&gt; &lt;!--pLanguage写不了驼峰，浏览器会识别为planguage--&gt; &lt;span v-for=\"item in s.planguage\"&gt;&#123;&#123;item&#125;&#125; - &lt;/span&gt; &lt;br/&gt; &lt;!--数组.join() 分隔数组--&gt; &lt;span&gt;&#123;&#123;s.planguage.join(' # ')&#125;&#125;&lt;/span&gt; &lt;br/&gt; &lt;span&gt;&#123;&#123;s.abc&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;!--插槽，设置:data数据，可以传到外面--&gt; &lt;slot :planguage=\"pLanguage\" :abc=\"abc\"&gt; &lt;ul&gt; &lt;li v-for=\"item in pLanguage\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('cpn', &#123; template: '#cpn', data() &#123; return &#123; pLanguage: ['Java', 'C', 'C++', 'JavaScript', 'Python', 'Linux'], abc: 'abc' &#125; &#125; &#125;)&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/body&gt; ES6模块化的导入和导出export导出 import导入 什么是Webpack从本质上将，webpack是一个现代的JavaScript应用的静态模块打包工具。 【前端模块化】【打包】 webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系，而且不仅仅是JavaScript文件，我们的CSS、图片、JSON文件等等在webpack中都可以被当做模块来使用。 grunt/gulp和we bpack有什么不同呢？ grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心 webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是它附带的功能。 webpack运行需要依赖node环境 node环境为了可以正常执行很多代码，必须包含各种依赖的包；所以管理各种包需要一种管理工具：npm工具（node packages manager） 安装webpack首先要安装Node.js，Node.js自带了软件包管理工具npm node -v 查看node版本 全局安装webpack（这里我先指定版本号3.6.0，因为vue cli2依赖该版本） 全局安装webpack：npm install webpack@3.6.0 -g 查看版本webpack –version 局部安装webpack(后续才需要)。–save-dev是开发时依赖，项目打包后不需要继续使用的 cd 对应目录 npm install webpack@3.6.0 –save-dev 为什么全局安装后还需要局部安装的： 在终端直接执行webpack命令，使用的是全局安装的webpack 当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack ==================================================== other: 数组.push() 数组.splice() ==== .toFixed(2) 保留两位小数 ==== unfinish 44.JS高级函数和多张种方式的for 59.props的驼峰命名问题，先不用驼峰，用-分隔 65 watch 74 ES6导入导出 ===== typeof 变量名 -》获取变量的类型 ======== Vue CLI3.X（构造Vue的项目） Vue2.5.21 =================== 不推荐子组件修改子组件的props数据，让父组件修改子组件的props数据 ============","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://github.com/hzebin/tags/Vue/"}]},{"title":"使用AspectJ实现AOP","slug":"使用AspectJ实现Spring AOP","date":"2020-01-10T12:32:44.712Z","updated":"2020-01-10T12:39:12.503Z","comments":true,"path":"2020/01/10/使用AspectJ实现Spring AOP/","link":"","permalink":"http://github.com/hzebin/2020/01/10/使用AspectJ实现Spring AOP/","excerpt":"","text":"使用AspectJ实现AOPAspect简介AspectJ是一个基于Java语言的AOP框架 Spring2.0以后新增了对AspectJ切点表达式支持 @AspectJ是AspectJ 1.5新增的功能，通过JDK5注解技术，允许直接在Bean类中定义切面 新版本Spring框架，建议使用AspectJ方式来开发AOP 12345使用AspectJ需要引入Spring AOP和AspectJ相关Jar包：spring-aopaopalliancespring-aspectsaspectjweaver 案例使用的代码： https://github.com/hzebin/SpringAOP_AspectJ 使用AspectJ是，xml配置文件格式12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--上面为aop的xml配置--&gt; &lt;!--开启aspectJ的注解开发，自动代理--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!--下面开始编写代码--&gt;&lt;/beans&gt; @AspectJ提供的通知类型 通知类型 说明 @Before 前置通知，相当于BeforeAdvice @AfterReturning 后置通知，相当于AfterReturningAdvice @Around 环绕通知，相当于AfterReturningAdvice @AfterThrowing 异常抛出通知，相当于ThrowAdvice @After 最终通知（相当于try-catch的finally），不管是否异常，该通知都会执行 @DeclareParents 引介通知，相当于IntroductionInterceptor 使用的例子(注解方式)step1:创建Maven项目（Webapp）step2:引入jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.hzebin&lt;/groupId&gt; &lt;artifactId&gt;im_spring_aspect&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;im_spring_aspect Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring开发包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring AOP需要引入的包--&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--AspectJ需要引入的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;im_spring_aspect&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; step3 - 1:创建目标类12345678910111213141516171819package cn.hzebin.demo1;public class ProductDao &#123; public void add() &#123; System.out.println(\"增加操作\"); &#125; public void update() &#123; System.out.println(\"修改操作\"); &#125; public void find() &#123; System.out.println(\"查询操作\"); &#125; public void delete() &#123; System.out.println(\"删除操作\"); &#125;&#125; step3 - 2:创建切面类JoinPoint类可以获得切入点信息 12345678910111213141516171819package cn.hzebin.demo1;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;/** * AspectJ定义切面类，注解方式 */@Aspect //表明这是切面类public class MyAspectAnno &#123; //前置通知// @Before(value = \"execution(* cn.hzebin.demo1.ProductDao.*(..))\") @Before(value = \"execution(* cn.hzebin.demo1.ProductDao.add(..))\") public void before(JoinPoint joinPoint) &#123; //JoinPoint为获得切入点信息 System.out.println(\"前置通知\" + joinPoint); &#125;&#125; step4:创建applicationContext.xml配置文件123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--上面为aop的xml配置--&gt; &lt;!--开启aspectJ的注解开发，自动代理--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!--下面开始编写代码--&gt; &lt;!--cn.hzebin.demo1--&gt; &lt;!--目标类--&gt; &lt;bean id=\"productDao\" class=\"cn.hzebin.demo1.ProductDao\"&gt;&lt;/bean&gt; &lt;!--定义切面--&gt; &lt;bean class=\"cn.hzebin.demo1.MyAspectAnno\"&gt;&lt;/bean&gt;&lt;/beans&gt; step5:使用12345678910111213141516171819202122232425262728package cn.hzebin.demo1;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/*AspectJ 切面 使用案例 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringDemo1 &#123; @Resource(name = \"productDao\") private ProductDao productDao; @Test public void demo1() &#123; productDao.add(); productDao.delete(); productDao.find(); productDao.update(); &#125;&#125; @Before前置通知可以在方法中传入JoinPoint对象，用来获得切点的信息 1234567//前置通知// @Before(value = \"execution(* cn.hzebin.demo1.ProductDao.*(..))\")@Before(value = \"execution(* cn.hzebin.demo1.ProductDao.add(..))\")public void before(JoinPoint joinPoint) &#123; //JoinPoint为获得切入点信息 System.out.println(\"==前置通知==,可以获得切入点信息\" + joinPoint);&#125; @AfterReturning后置通知通过returning属性，可以定义方法返回值，作为参数 12345//后置通知@AfterReturning(value = \"execution(* cn.hzebin.demo1.ProductDao.update(..))\", returning = \"result\")public void demo2(Object result) &#123; System.out.println(\"==后置通知==，可以获得切入点的返回值 -&gt; \" + result);&#125; @Around环绕通知around方法的返回值就是目标代理方法执行返回值 参数为ProceedingJoinPoint，可以拦截目标方法的执行 12345678//环绕通知@Around(value = \"execution(* cn.hzebin.demo1.ProductDao.delete(..))\")public Object demo3(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"环绕前的通知\"); Object obj = joinPoint.proceed(); //执行目标方法，会有目标方法的返回值，可以不调用，则为拦截 System.out.println(\"环绕后的通知\"); return obj;&#125; @AfterThrowing异常通知通过设置throwing属性，可以设置发生异常对象参数 12345//异常通知@AfterThrowing(value = \"execution(* cn.hzebin.demo1.ProductDao.find(..))\", throwing = \"e\")public void demo4(Throwable e) &#123; System.out.println(\"异常通知，\" + e.getMessage());&#125; @After最终通知无论是否发生异常，最终通知总是会被执行 12345//最终通知@After(value = \"execution(* cn.hzebin.demo1.ProductDao.findOne(..))\")public void demo5() &#123; System.out.println(\"最终通知\");&#125; @Pointcut可以给切点命名 在每个通知内定义切点，会造成工作量大，不易维护，对于重复的切点，可以使用@Pointcut进行定义 切点方法：private void 切点名() {} 当通知多个切点时，可以使用||进行连接 123456789101112131415161718192021222324252627282930313233343536package cn.hzebin.demo2;import org.aspectj.lang.annotation.*;/** * 给切点命名，维护代码更加方便 */@Aspectpublic class AspectAnno &#123; @Before(value = \"myPointCut1() || myPointCut2()\") //多个切点可以使用||进行连接 public void demo1() &#123; System.out.println(\"前置通知\"); &#125; @AfterReturning(value = \"myPointCut2()\", returning = \"result\") public void demo2(Object result) &#123; System.out.println(\"后置通知\" + result); &#125; //给切点命名 @Pointcut(value = \"execution(* cn.hzebin.demo2.ProductDao.add(..))\") private void myPointCut1() &#123;&#125; @Pointcut(value = \"execution(* cn.hzebin.demo2.ProductDao.delete(..))\") private void myPointCut2() &#123;&#125; @Pointcut(value = \"execution(* cn.hzebin.demo2.ProductDao.update(..))\") private void myPointCut3() &#123;&#125; @Pointcut(value = \"execution(* cn.hzebin.demo2.ProductDao.findOne(..))\") private void myPointCut4() &#123;&#125; @Pointcut(value = \"execution(* cn.hzebin.demo2.ProductDao.findAll(..))\") private void myPointCut5() &#123;&#125;&#125; Aspect的XML配置== 【unfinish】 ==","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://github.com/hzebin/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://github.com/hzebin/tags/AOP/"},{"name":"Aspect","slug":"Aspect","permalink":"http://github.com/hzebin/tags/Aspect/"}]},{"title":"Spring IOC","slug":"Spring IOC","date":"2020-01-08T12:51:26.595Z","updated":"2020-01-08T13:25:12.593Z","comments":true,"path":"2020/01/08/Spring IOC/","link":"","permalink":"http://github.com/hzebin/2020/01/08/Spring IOC/","excerpt":"","text":"Spring IOCSpring IOC 练习的代码地址： https://github.com/hzebin/SpringIOC ===================================== Spring IOC的底层原理：工厂模式 + 反射 + 配置文件 【为了减少程序之间的耦合性】 IOC (Inverse of Control)控制反转，将原本在程序中手动创建的对象（例如UserService）的控制权，交由Spring框架管理。 DI(Dependency Injection)依赖注入，就是在Spring创建这个对象的过程中，将这个对象所依赖的属性注入进去。 使用Spring IOC需要导入的jar包 123456789// 四个核心包spring-beansspring-contextspring-corespring-expression// 还要引入commons-logginglog4jjunit Spring的Bean管理(XML方式)12345678910&lt;!--applicationContext.xml配置文件--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; Bean的实例化有三种方式： 采用无参数的构造方法方式 静态工厂的实例化方式 实例工厂实例化 1234567891011&lt;!--Bean实例化的三种方式==================================================--&gt;&lt;!--1.采用无参数的构造方法的方式--&gt;&lt;bean id=\"bean1\" class=\"cn.hzebin.ioc.demo2.Bean1\"&gt;&lt;/bean&gt;&lt;!--2.静态工厂的方式,因为是静态方法，所以可以用类.方法直接使用--&gt;&lt;bean id=\"bean2\" class=\"cn.hzebin.ioc.demo2.Bean2Factory\" factory-method=\"createBean2\"&gt;&lt;/bean&gt;&lt;!--3.实例工厂的方式--&gt;&lt;bean id=\"bean3Factory\" class=\"cn.hzebin.ioc.demo2.Bean3Factory\"&gt;&lt;/bean&gt;&lt;bean id=\"bean3\" factory-bean=\"bean3Factory\" factory-method=\"createBean3\"&gt;&lt;/bean&gt; Bean配置里的属性：id和name: id和name效果是一样的。一般情况下装配一个Bean时，通过指定一个id属性作为Bean的名称。 id属性在IOC容器中必须是唯一的。 如果Bean的名称中含有特殊字符（例如name=”/studentService”），就要改为使用name属性（id不能含有特殊字符）。 class: class用于设置一个类的完全路径名称，主要的作用是给IOC容器生成类的实例。 Bean的作用域属性scope: 类别 说明 singleton（默认情况下是单例） 在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在 prototype（多例） 每次调用getBean()时都会返回一个新的实例 request 每次HTTP请求都会创建一个新的Bean，该作用域只适合于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。该作用域只适合于WebApplicationContext环境 init-method和destory-method属性 20190108A.png Tip:如果是多例的话，程序不知道销毁谁 Spring的属性注入–构造方法注入 通过构造方法注入Bean的属性值或依赖对象，它保证了Bean实例在实例化之后就可以使用了 构造器注入在元素里申明的属性 12345&lt;!--构造方法注入--&gt;&lt;bean id=\"user\" class=\"cn.hzebin.ioc.demo4.User\"&gt; &lt;constructor-arg name=\"name\" value=\"黄泽彬\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"22\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; Spring的属性注入–set方法注入 使用set方法注入，在Spring配置文件中，通过设置注入的属性 123456&lt;bean id=\"person\" class=\"cn.hzebin.ioc.demo4.Person\"&gt; &lt;property name=\"name\" value=\"熊君\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;property name=\"cat\" ref=\"cat\"&gt;&lt;/property&gt; &lt;!--注入对象 ref为引用下面的bean的id--&gt;&lt;/bean&gt;&lt;bean id=\"cat\" class=\"cn.hzebin.ioc.demo4.Cat\"&gt;&lt;/bean&gt; Spring的属性注入–p名称空间 为了简化XML文件配置，Spring2.5开始引入一个新的p名称空间 p:&lt;属性名&gt; = “xxx” 引入常量值 p:&lt;属性名&gt;-ref = “xxx” 引入其他Bean对象 12345需要在applicationContext.xml头部添加：xmlns:p=\"http://www.springframework.org/schema/p\"&lt;bean id=\"cat\" class=\"cn.hzebin.ioc.demo4.Cat\" p:name=\"小猫\"&gt;&lt;/bean&gt;&lt;bean id=\"person\" class=\"cn.hzebin.ioc.demo4.Person\" p:name=\"胡文瀚\" p:age=\"23\" p:cat-ref=\"cat\"&gt;&lt;/bean&gt; Spring的属性注入–SpEL注入(Spring expresssion language) Spring表达式语言，对依赖注入进行简化 语法： #{表达式} &lt;bean id=”” value=”#{表达式}” 1234#&#123;'hello'&#125; 使用字符串#&#123;beanId&#125; 使用另一个bean#&#123;beanId.content.toUpperCase()&#125; 使用指定名属性，并使用方法#&#123;T(java.lang.Math).PI&#125; 使用静态字段或方法 12345678910111213&lt;!--Bean的SpEL注入方式属性注入--&gt;&lt;bean id=\"category\" class=\"cn.hzebin.ioc.demo4.Category\"&gt; &lt;property name=\"name\" value=\"#&#123;'服装'&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"productInfo\" class=\"cn.hzebin.ioc.demo4.ProductInfo\"&gt;&lt;/bean&gt;&lt;bean id=\"product\" class=\"cn.hzebin.ioc.demo4.Product\"&gt; &lt;property name=\"name\" value=\"#&#123;'裤子'&#125;\"&gt;&lt;/property&gt; &lt;!-- &lt;property name=\"price\" value=\"#&#123;299&#125;\"&gt;&lt;/property&gt; 下面采用调用方法的方式--&gt; &lt;property name=\"price\" value=\"#&#123;productInfo.calculatePrice()&#125;\"&gt;&lt;/property&gt; &lt;property name=\"category\" value=\"#&#123;category&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; Spring的复杂类型的属性注入类型包括：数组、List集合、Set集合、Map集合、Properties 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--复杂（集合）类型的属性注入--&gt;&lt;bean id=\"collectionBean\" class=\"cn.hzebin.ioc.demo5.CollectionBean\"&gt; &lt;!--数组类型--&gt; &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--list类型--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;value&gt;333&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--set类型--&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;ddd&lt;/value&gt; &lt;value&gt;eee&lt;/value&gt; &lt;value&gt;fff&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--Map集合的属性注入--&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"aaa\" value=\"111\"&gt;&lt;/entry&gt; &lt;entry key=\"bbb\" value=\"222\"&gt;&lt;/entry&gt; &lt;entry key=\"ccc\" value=\"333\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--properties属性注入--&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;root1234&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 使用注解定义Bean使用Spring注解的使用需要引入的jar包：spring-aop 1234567891011121314&lt;!--applicationContext.xml配置文件--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 模板 xsd-configuration.html 40.2.8 the context schema--&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"cn.hzebin\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 注解 说明 @Component 描述Spring框架中的Bean（相当于id） 上面这个注解与下面的注解等价，推荐使用下面的注解 @Repository 用于对Dao实现类进行标注 @Service 用于对Service实现类进行标注 @Controller 用于对Controller实现类进行标注 注解 说明 @Value(“”) 给属性添加值的注解 注解 说明 @Autowired 属性注入，默认按类型注入（id名不相同也行），也可以按id名称注入 注解 说明 @Autowired @Qualifier(“userDao”) 注入的类型和id名称都要相同 上面的注解与下面的注解等价 @Resource(name = “”) 注解 说明 @PostConstruct 初始化，当Bean被载入导容器的时候调用该方法，与init-method作用相同 @PreDestroy 销毁，当Bean从容器中删除的时候调用该方法（单例才有效，与destory-method作用相同） @Scope(“”) Bean的作用域 XML配置和注解各有优缺点，可以将XML配置与注解配置混合使用XML配置的优点：结构清晰、易于理解 注解配置的优点：开发便捷、属性注入方便 XML与注解整合开发【使用XML来管理类，使用注解来进行属性注入】 使用步骤： 引入context命名空间 在配置文件中添加context:annotattion-config标签 【意思：开启属性注入注解，禁止类注解】","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://github.com/hzebin/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"http://github.com/hzebin/tags/IOC/"}]},{"title":"JDBC连接数据库","slug":"JDBC连接数据库","date":"2019-12-30T15:37:22.270Z","updated":"2019-12-30T15:39:29.994Z","comments":true,"path":"2019/12/30/JDBC连接数据库/","link":"","permalink":"http://github.com/hzebin/2019/12/30/JDBC连接数据库/","excerpt":"","text":"JDBC（Java Data Base Connectivity )，Java数据库连接 使用方式：需要添加驱动包，将驱动包配置到lib，并将lib添加到Build Path 12345678910111213141516171819202122232425262728DriverManager 驱动管理类 作用一：1. 注册驱动 2. 获得数据库连接Connection 连接对象 作用：1. 创建执行SQL语句的对象 Statement createStatement() 执行SQL语句，有SQL注入的危险 PreparedStatement prepareStatement(String sql) 预编译SQL语句，解决SQL注入问题 CallableStatement prepareCall(String sql) 执行SQL中的存储过程 2. 进行事务管理 setAutoCommit(boolean autoCommit) 设置事务是否自动提交 commit() 事务提交 rollback() 事务回滚Statement 执行SQL语句 作用： 1. 执行SQL语句 boolean execute(String sql) 执行SQL,执行的是select则返回true，否则返回false ResultSet executeQuery(String sql) 执行SQL中的select语句 int executeUpdate(String sql) 执行SQL中的insert/update/delete 2. 执行批处理操作 addBatch(String sql) 添加到批处理 executeBatch() 执行批处理 clearBatch() 清空批处理 ResultSet 结果集 .next() .getXxx() .getObject(...) JDBC的资源释放 .close() Connection对象要及时、正确关闭，尽量晚创建、尽量早释放 1234SQL注入漏洞 1. 在连接sql语句中插入or关键字 2. 在连接sql语句中插入注释字符--解决办法：使用PreparedStatement，该变量出用?代替，变量的赋值下表从1开始 1234数据库连接池： 连接池是创建和管理一个连接的缓冲池技术，这些连接准备好了被任何需要它们的线程使用。 C3P0连接池，默认查找src路径下C3P0的配置文件 存放在github中的JDBC示例代码： https://github.com/hzebin/JavaStudy_JDBC","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://github.com/hzebin/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://github.com/hzebin/tags/JDBC/"}]},{"title":"Python网络爬虫--Scrapy框架","slug":"Python网络爬虫--Scrap框架","date":"2019-12-03T09:00:00.000Z","updated":"2019-12-03T09:06:33.451Z","comments":true,"path":"2019/12/03/Python网络爬虫--Scrap框架/","link":"","permalink":"http://github.com/hzebin/2019/12/03/Python网络爬虫--Scrap框架/","excerpt":"","text":"Scrapy 专业爬虫框架 Scarpy框架：5+2结构 requests与Scrapy的比较 相同点： 两者都可以进行页面的请求和爬取，Python爬虫的两个重要技术路线 两者可用性都好，文档丰富，入门简单 两者都没有处理js、提交表单、对应验证码等功能（可扩展） 不同点： requests Scrapy 页面级爬虫 网站级爬虫 功能库 框架 并发性考虑不足，性能较差 并发性好，性能较高【性能过高也不好，会骚扰服务器性能】 重点在于页面下载 重点在于爬虫结构 定制灵活 一般定制灵活，深度定制困难 上手十分简单 入门较难 如何选择 非常小的需求，使用requests库 不太小的需求，Scrapy框架 定制程度很高的需求（不考虑规模）：自搭框架，requests &gt; Scrapy 12Scrapy命令行格式scrapy &lt;command&gt; [options] [args] # command为Scrapy命令 Scrapy常用命令 说明 格式 startproject 创建一个新工程 scrapy startproject [dir] genspider 创建一个爬虫 scrapy genspider [options] settings 获得爬虫配置信息 scrapy settings [options] crawl 运行一个爬虫 scrapy crawl list 列出工程中所有爬虫 scrapy list shell 启动URL调式命令行 scrapy shell [url]","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"http://github.com/hzebin/tags/Scrapy/"}]},{"title":"Python网络爬虫--正则表达式","slug":"Python网络爬虫（五）","date":"2019-12-02T23:00:00.000Z","updated":"2019-12-03T09:05:56.082Z","comments":true,"path":"2019/12/03/Python网络爬虫（五）/","link":"","permalink":"http://github.com/hzebin/2019/12/03/Python网络爬虫（五）/","excerpt":"","text":"正则表达式RE 正则表达式常用操作符 操作符 说明 实例 . 表示任何单个字符 [] 字符集，对单个字符给出取值范围 [abc]表示a、b、c，[a-z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次到无限次扩展 abc* 表示 ab、abc、abcc、abccc等 + 前一个字符1到无限次扩展 abc+ 表示 abc、abcc、abccc等 ？ 前一个字符0或1次扩展 abc? 表示 ab、abc | 左右表达式任选一个 {m} 扩展前一个字符m次 ab{2}c表示abbc {m, n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 () 分组标记，内部只能使用|操作符 \\d 数字，等价于[0-9] \\w 单词字符，等价于[A-Za-z0-9_] import re Re库是Python的标准库，主要用于字符串匹配 正则表达式的表示类型 raw string类型（原生字符串类型），re库采用此类型，表示为 r’text’ 。raw string是不包含对转义符再次转义的字符串【原生字符串中间的\\不被解释为转义字符】。例如 1r&apos;[1‐9]\\d&#123;5&#125;&apos; 也可以采用string类型表示正则表达式，但更繁琐。例如 1&apos;[1‐9]\\\\d&#123;5&#125;&apos; 建议使用raw string类型 Re库主要功能函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个结果的迭代类型，每个迭代元素是match对象 re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 1234re.search(pattern, string, flags=0) pattern: 正则表达式的字符串或原生字符串表示 string: 待匹配字符串 flags: 正则表达式使用时的控制标记 flags常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写，[A‐Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 用if判断匹配结果是否为空，否则会报错 123456789101112131415161718192021222324252627282930313233343536373839import re# re.search(pattern, string, flags=0)match = re.search(r'[1-9]\\d&#123;5&#125;', 'BIT 100081')if match: print(match.group(0)) #输出100081# re.match(pattern, string, flags = 0)match = re.match(r'[1-9]\\d&#123;5&#125;', 'BIT 100081')if match: print(\"--\") print(match.group(0)) # 没有进到if print(\"--\")match = re.match(r'[1-9]\\d&#123;5&#125;', '100081 BIT')if match: print(match.group(0))# re.findall(pattern, string, flags = 0)ls = re.findall(r'[1-9]\\d&#123;5&#125;', 'BIT100081 TSU100084')print(ls)# re.split(pattern, string, maxsplit=0, flag=0)# maxsplit: 最大分割数，剩余部分作为最后一个元素输出ls = re.split(r'[1-9]\\d&#123;5&#125;', 'BIT100081 TSU100084')print(ls)ls = re.split(r'[1-9]\\d&#123;5&#125;', 'BIT100081 TSU100084', maxsplit = 1)print(ls)# re.finditer(pattern, string, flags=0)for m in re.finditer(r'[1-9]\\d&#123;5&#125;', 'BIT100081 TSU100084'): if m: print(m.group(0))# re.sub(pattern, repl, string, count=0, flags=0)# repl: 替换匹配字符串的字符串# string: 带匹配字符串# count: 匹配的最大替换次数str = re.sub(r'[1-9]\\d&#123;5&#125;', ':zipcode', 'BIT100081 TSU100084')print(str) Re库的两种使用方式： 函数式用法：一次性操作 1rst = re.search(r'[1-9]\\d&#123;5&#125;', 'BIT 100084') 面向对象用法：编译后可以多次操作 12345678910111213regex = re.compile(r'[1-9]\\d&#123;5&#125;') #将正则表达式的字符串形式编译成正则表达式对象rst = regex.search('BIT 100081')'''等价写法：regex.search()regex.match()regex.findall()regex.split()regex.finditer()regex.sub()''' Match对象是一次匹配的结果，包含匹配的很多信息 123456import rematch = re.search(r'[1-9]\\d&#123;5&#125;', 'BIT 100081')if match: print(match.group(0))print(type(match)) Match对象的属性 说明 .string 待匹配的文本 .re 匹配时使用的patter对象（正则表达式） .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 Match对象的方法 说明 .group(0) 获得匹配后的字符串 .start() 匹配字符串在原始字符串的开始位置 .end() 匹配字符串在原始字符串的结束位置 .span() 返回(.start(), .end()) 12345678910111213141516import rematch = re.search(r'[1-9]\\d&#123;5&#125;', 'BIT 100081')if match: print(match.group(0))print(type(match))m = re.search(r'[1-9]\\d&#123;5&#125;', 'BIT100081 TSU100084')print(m.string)print(m.re)print(m.pos)print(m.endpos)print(m.group(0))print(m.start())print(m.end())print(m.span()) Re库默认采用贪婪匹配，即输出匹配最长的子串 最小匹配字符串的操作符 *? +? ?? {m, n}?","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"},{"name":"re","slug":"re","permalink":"http://github.com/hzebin/tags/re/"}]},{"title":"Python网络爬虫--案例--中国大学排名","slug":"Python网络爬虫--案例--中国大学排名","date":"2019-12-02T08:00:00.000Z","updated":"2019-12-02T08:49:43.928Z","comments":true,"path":"2019/12/02/Python网络爬虫--案例--中国大学排名/","link":"","permalink":"http://github.com/hzebin/2019/12/02/Python网络爬虫--案例--中国大学排名/","excerpt":"","text":"python爬虫案例：中国大学排名定向爬虫 功能描述： 输入：大学排名URL链接 输出：大学牌型信息的屏幕输出（排名， 大学名称， 总分） 使用的库：requests，bs4 定向爬虫：仅对输入URL进行爬取，不扩展爬取 【先判断网页中的数据是否动态生成，能否在源代码中获取数据信息】 【查看Robots协议】 设计步骤： 从网络上获取大学排名网页内容 提取网页内容中的信息到合适的数据结构中 利用数据结构展示并输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsfrom bs4 import BeautifulSoup #引入的是BuautifulSoup类import bs4# 获取页面的HTML代码def getHTMLText(url): try: r = requests.get(url, timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\"# 将数据放在列表中def fillUnivList(ulist, html): soup = BeautifulSoup(html, 'html.parser') for tr in soup.find('tbody').children: # 判断节点，排除字符串节点 if isinstance(tr, bs4.element.Tag): tds = tr('td') #find_all缩写 ulist.append([tds[0].string, tds[1].string, tds[3].string])# 输出排名def printUnivList(ulist, num): # print(\"&#123;:^10&#125;\\t&#123;:^10&#125;\\t&#123;:^10&#125;\".format(\"排名\", \"学校\", \"总分\")) # for i in range(num): # temp = ulist[i] # print(\"&#123;:^10&#125;\\t&#123;:^10&#125;\\t&#123;:^10&#125;\".format(temp[0], temp[1], temp[2])) # 当中文字符宽度不够时，采用西文字符填充，中西文字符占用宽度不同 # 解决办法：空格用中文字符填充 tmpl = \"&#123;0:&#123;3&#125;^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:&#123;3&#125;^10&#125;\" print(tmpl.format(\"排名\", \"学校\", \"总分\", chr(12288))) for i in range(num): temp = ulist[i] print(tmpl.format(temp[0], temp[1], temp[2], chr(12288)))def main(): uinfo = [] url = \"http://zuihaodaxue.cn/zuihaodaxuepaiming2019.html\" html = getHTMLText(url) fillUnivList(uinfo, html) #注意列表uinfo和ulist # print(uinfo) printUnivList(uinfo, 20) #输出前20main()","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"}]},{"title":"Python网络爬虫（四）","slug":"Python网络爬虫（四）","date":"2019-12-02T07:00:00.000Z","updated":"2019-12-02T07:18:55.517Z","comments":true,"path":"2019/12/02/Python网络爬虫（四）/","link":"","permalink":"http://github.com/hzebin/2019/12/02/Python网络爬虫（四）/","excerpt":"","text":"三种信息标记形式 XML 最早的通用信息标记语言，可拓展性好，但繁琐。适合Internet上的信息交互与传递 123456789&lt;person&gt; &lt;firstName&gt;Tian&lt;/firstName&gt; &lt;lastName&gt;Song&lt;/lastName&gt; &lt;address&gt; &lt;streetAddr&gt;中关村南大街5号&lt;/streetAddr&gt; &lt;city&gt;北京市&lt;/city&gt; &lt;zipcode&gt;100081&lt;/zipcode&gt; &lt;/address&gt; &lt;prof&gt;Computer System&lt;/prof&gt;&lt;prof&gt;Security&lt;/prof&gt;&lt;/person&gt; JSON 信息有类型，适合程序处理（js)，较XML简洁。适合应用云端和节点的信息通信，但没有注释 12345678910&#123; “firstName”: “Tian”, “lastName”: “Song”, “address”: &#123; “streetAddr” :“中关村南大街5号”, “city” :“北京市”, “zipcode” :“100081” &#125;, “prof”: [ “Computer System” ,“Security” ]&#125; YAML 信息无类型，文本信息比例较高，可读性好。适合各类系统的配置文件，有注释易读 123456789firstName: TianlastName: Songaddress: streetAddr: 中关村南大街5号 city: 北京市 zipcode: 100081prof:‐Computer System‐Security 123456789101112131415# 提取HTML中的所有URL链接from bs4 import BeautifulSoupimport requestsurl = 'http://python123.io/ws/demo.html'try: r = requests.get(url) r.raise_for_status() soup = BeautifulSoup(r.text, 'html.parser') #提取链接 for link in soup.find_all('a'): print(link.get('href'))except: print(\"爬取失败\") 12345678910&lt;&gt;.find_all(name, attrs, recursive, string, **kwargs)返回一个列表类型，存储查找的结果name: 对标签名称的检索字符串attrs: 对标签属性值的检索字符串，可标注属性检索recursive: 是否对子孙全部检索，默认为True。搜索当前节点儿子层面为Falsestring: &lt;&gt;...&lt;/&gt;中字符串区域的检索字符串&lt;tag&gt;(...) 等价于 &lt;tag&gt;.find_all(...)soup(...) 等价于 soup.find_all(...) 1234567891011121314151617181920212223242526272829303132import requestsimport refrom bs4 import BeautifulSoupurl = 'http://python123.io/ws/demo.html'try: r = requests.get(url) r.raise_for_status() soup = BeautifulSoup(r.text, 'html.parser') print(\"查找a标签：\\n\", soup.find_all('a')) print(\"查找a,b标签：\\n\", soup.find_all(['a', 'b'])) print(\"显示所有标签信息：\\n\", soup.find_all(True)) print(\"----\") for tag in soup.find_all(True): print(tag.name) print(\"----\") for tag in soup.find_all(re.compile('b')): print(tag.name) print(\"属性值检索：\\n\", soup.find_all('p', 'course')) print(\"标签属性值检索：\\n\", soup.find_all(id=\"link1\")) print(\"检索：\\n\", soup.find_all(id=\"link\")) print(\"检索：\\n\", soup.find_all(id=re.compile('link'))) print(\"在儿子层面搜索，不搜索子孙全部：\\n\", soup.find_all('a', recursive=False)) print(\"检索：\\n\", soup.find_all(string=\"Basic Python\")) print(\"检索：\\n\", soup.find_all(string=re.compile('python')))except: print(\"爬取失败\") 检索方法 说明 &lt;&gt;.find_all() &lt;&gt;.find() 搜索且只返回一个结果，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型 &lt;&gt;.find_parent() 在先辈节点中返回一个结果 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回列表类型 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果 &lt;&gt;.find_previous_siblings() 在前序平行节点中搜索，返回列表类型 &lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"}]},{"title":"Python网络爬虫（三）","slug":"Python网络爬虫（三）","date":"2019-12-02T01:00:00.000Z","updated":"2019-12-02T01:29:46.518Z","comments":true,"path":"2019/12/02/Python网络爬虫（三）/","link":"","permalink":"http://github.com/hzebin/2019/12/02/Python网络爬虫（三）/","excerpt":"","text":"Beautiful Soup库 解析HTML页面 pip install beautifulsoup4 1234567891011121314BeautifulSoup库的初次使用方法# 解析格式化html树import requestsfrom bs4 import BeautifulSoupurl = \"http://python123.io/ws/demo.html\"try: r = requests.get(url) r.raise_for_status() demo = r.text #网页的源代码 soup = BeautifulSoup(demo, 'html.parser') print(soup.prettify())except: print(\"爬取失败\") 123456Beautiful Soup库是解析、遍历、维护“标签树”的功能库Beautiful Soup库引用方式：from bs4 import BeautifulSoupsoup1 = BeautifulSoup(\"&lt;html&gt;data&lt;/html&gt;\", 'html.parser') #(文档内容, 解析器)soup2 = BeautifulSoup(open(\"D://demo.html\"), 'html.parser') #BeautifulSoup对应一个HTML/XML文档的全部内容 BeautifulSoup库解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk, ‘html.parser’) 安装bs4库 lxml的HTML解析器 BeautifulSoup(mk, ‘lxml’) pip install lxml lxml的XML解析器 BeautifulSoup(mk, ‘xml’) pip install lxml html5lib的解析器 BeautifulSoup(mk, ‘html5lib’) pip install html5lib BeautifulSoup类的基本元素 说明 Tag 标签，分别用&lt;&gt;和&lt;/&gt;表明开头和结尾，返回标签及其内容 Name 标签的名字，…的名字是’p’（字符串类型），格式：.name Attributes 标签的属性，字典形式组织，格式：.attrs NavigableString 标签内非属性字符串，&lt;&gt;…&lt;/&gt;中的字符串，格式：.string Comment 标签内字符串的注释部分，一种特殊的Comment类型，格式：.string Tag标签：HTML语法中的标签都可以用soup.访问获得，当文档中存在多个相同的对应的内容是，soup.返回第一个 NavigableString：可以跨越多个层次 NavigableString和Comment都是.string，判断是非属性字符串还是注释要用type()判断 12345678910111213141516171819202122232425262728293031323334353637383940import requestsfrom bs4 import BeautifulSoupurl = 'http://python123.io/ws/demo.html'try: r = requests.get(url) r.raise_for_status() demo = r.text #页面的源代码保存在demo print(\"页面源代码：\\n\", demo) soup = BeautifulSoup(demo, 'html.parser') #熬一碗鲜美的汤 print(\"格式化树：\\n\", soup) print(\"titlt标签：\\n\", soup.title) print(\"a标签：\\n\", soup.a) print(\"a标签的名字：\\n\", soup.a.name) print(\"a标签父亲的名字：\\n\", soup.a.parent.name) print(\"a标签的父亲的父亲的名字：\\n\", soup.a.parent.parent.name) tag = soup.a print(\"tag标签的全部属性：\\n\", tag.attrs) print(\"tag标签的类型：\\n\", type(tag)) print(\"tag.attrs的类型：\\n\", type(tag.attrs)) #字典类型 print(\"class属性：\\n\", tag.attrs['class']) print(\"href属性：\\n\", tag.attrs['href']) print(\"a标签：\\n\", soup.a) print(\"a标签内非属性字符串：\\n\", soup.a.string) print(\"p标签：\\n\", soup.p) print(\"p标签内的非属性字符串：\\n\", soup.p.string) #NavigableString可以跨越多个层次 print(\"类型：\\n\", type(soup.p.string)) soup2 = BeautifulSoup(\"&lt;b&gt;&lt;!--A This is a comment--&gt;&lt;/b&gt;&lt;p&gt;B This is a comment&lt;/p&gt;\", 'html.parser') print(\"soup2.b.string:\\n\", soup2.b.string) print(\"类型：\", type(soup2.b.string)) print(\"soup2.p.string:\\n\", soup2.p.string) print(\"类型：\", type(soup2.p.string))except: print(\"爬取失败\") 基于bs4库的HTML内容遍历方法 标签树的下行遍历（BeautifulSoup类型是标签树的根节点） 属性 说明 .contents 子节点的列表，将所有儿子节点存入列表（包括\\n） .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有的子孙节点，用于循环遍历 标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签【】 平行遍历：包含\\n naviablestring也构成标签树的节点，所以平行遍历获得的下一个标签不一定是标签类型 平行遍历发生在同一个父节点下的各个节点间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 基于bs4库的HTML内容遍历方法import requestsfrom bs4 import BeautifulSoupurl = 'http://python123.io/ws/demo.html'try: r = requests.get(url) r.raise_for_status() soup = BeautifulSoup(r.text, 'html.parser') print(soup) # 标签树的下行遍历知识点 print(\"soup.head:\\n\", soup.head) print(\"soup.head的子列表：\\n\", soup.head.contents) print(\"soup.body的子列表：\\n\", soup.body.contents) print(\"长面的子列表长度为：\\n\", len(soup.body.contents)) #包括换行 print(\"soup.body.contents[1]:\\n\", soup.body.contents[1]) print(\"------------------------------------------------------\") # 标签树的下行遍历 遍历儿子节点 for child in soup.body.children: print(child) print(\"------------------------------------------------------\") for child in soup.body.descendants: print(\"*HZB*\", child) print(\"------------------------------------------------------\") # 标签树的上行遍历知识点 print(\"soup.title.parent:\\n\", soup.title.parent) print(\"soup.html.parent:\\n\", soup.html.parent) print(\"soup.parent:\\n\", soup.parent) # 上行遍历遍历所有先辈节点，包括soup本身，所以要区别判断 for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) # 平行遍历知识点 print(\"soup.a.next_sibling:\\n\", soup.a.next_sibling) print(\"soup.a.next_sibling.next_sibling:\\n\", soup.a.next_sibling.next_sibling) print(\"soup.a.previous_sibling:\\n\", soup.a.previous_sibling) print(\"soup.a.previous_sibling.previous_sibling:\\n\", soup.a.previous_sibling.previous_sibling) print(\"soup.a.parent:\\n\", soup.a.parent) # 平行遍历 遍历后续节点 print(\"----\") for sibling in soup.a.next_siblings: print(sibling) # 平行遍历 遍历前序节点 print(\"----\") for sibling in soup.a.previous_siblings: print(sibling) print(\"----\")except: print(\"爬取失败\") bs4库的prettify()方法可以格式化html代码，它会为HTML文本及其内容怎加'\\n'，python3默认支持utf-8编码，bs4库将任何HTML输入都编程utf-8编码 1234567891011121314151617# bs库的prettify()方法格式化代码import requestsfrom bs4 import BeautifulSoupurl = 'http://python123.io/ws/demo.html'try: r = requests.get(url) r.raise_for_status() soup = BeautifulSoup(r.text, 'html.parser') print(\"格式化代码：\\n\", soup.prettify()) print(\"----------\") print(\"标签格式化：\\n\", soup.a.prettify()) print(\"----------\") soup2 = BeautifulSoup(\"&lt;p&gt;中文&lt;/p&gt;\", 'html.parser') print(soup2.p.prettify())except: print(\"爬取失败\")","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"}]},{"title":"Python网络爬虫（二）","slug":"Python网络爬虫（二）","date":"2019-12-01T07:00:00.000Z","updated":"2019-12-01T07:58:13.187Z","comments":true,"path":"2019/12/01/Python网络爬虫（二）/","link":"","permalink":"http://github.com/hzebin/2019/12/01/Python网络爬虫（二）/","excerpt":"","text":"网络爬虫的尺寸 爬取网页 玩转网站 爬取网站 爬取系列网站 爬取全网 小规模，数据量小，爬取速度不敏感 Requests库 中规模，数据规模较大，爬取速度敏感 Scrapy库 大规模，搜索引擎，爬取速度关键，只能定制开发 网络爬虫带来的问题 对服务器的性能骚扰，消耗Web服务器的资源开销 服务器上的数据有产权归属，可能带来法律风险 爬虫可能具备突破简单访问控制的能力，获得被保护数据从而泄露个人隐私 网络爬虫的两种限制 判断User-Agent进行限制 检查来访的HTTP协议头的User-Agent域，只响应浏览器或友好爬虫访问 发布Robots协议 告知所有爬虫网站的爬虫策略，要求爬虫遵守 Robots协议 （网络爬虫排除标准） 作用：网站告知爬虫哪些页面可以抓取，哪些不行 形式：在网站的根目录下的robots.txt文件 语法：User-agent请求的是谁 Disallow不允许的位置 /代表根目录 *代表所有 网络爬虫先自动或人工识别roboot.txt，再进行内容爬取，如果不遵守协议可能带来风险，商业利益必须遵守 类人行为可以不参考Robots协议（不对服务器进行骚扰） 12345678910111213案例1：爬取京东的某件商品# 爬取京东的某件商品# url = https://item.jd.com/48918974270.htmlimport requestsurl = \"https://item.jd.com/48918974270.html\"try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[:1000])except: print(\"爬取失败\") 123456789101112131415案例2：模拟浏览器的请求头访问亚马逊商品# 模拟浏览器头部访问亚马逊商品import requestsurl = \"https://www.amazon.cn/gp/product/B01M8L5Z3Y\"try: # 模拟浏览器头部信息 kv = &#123;'user-agent': 'Mozilla/5.0'&#125; r = requests.get(url, headers = kv) print(\"头部信息为：\\n\", r.request.headers) # 注意request没有s r.raise_for_status() r.encoding = r.apparent_encoding print(\"爬取结果为：\\n\", r.text[1000:2000])except: print(\"爬取失败\") 1234567891011121314案例3：百度搜索关键词# 通过百度搜索关键词信息import requestsurl = \"https://www.baidu.com/s\"try: kv = &#123;'wd': 'Python'&#125; r = requests.get(url, params = kv) print(\"url地址为：\", r.request.url) r.raise_for_status() r.encoding = r.apparent_encoding print(\"所有信息的长度为：\\n\", len(r.text))except: print(\"爬取失败\") 1234567891011121314151617181920212223案例4：爬取图片并保存在本地（注意路径）# 图片的爬取import requestsimport osurl = \"http://photocdn.sohu.com/20151027/Img424310423.jpg\"root = \"D://PyCharm_file//workplace//images//\"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) # print(r.status_code) print(path) with open(path, \"wb\") as f: f.write(r.content) #二进制写 f.close() print(\"文件保存成功\") else: print(\"文件已存在\")except: print(\"爬取失败\") 1234567891011案例5：通过网站API查询IP地址# 通过网站的API查询ip地址import requestsurl = \"http://m.ip138.com/ip.asp?ip=\"try: r = requests.get(url + '202.204.80.112') r.raise_for_status() r.encoding = r.apparent_encoding print(r.text[-500:])except: print(\"爬取失败\")","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"}]},{"title":"Python网络爬虫（一）","slug":"Python网络爬虫（一）","date":"2019-11-30T10:00:00.000Z","updated":"2019-11-30T11:56:50.758Z","comments":true,"path":"2019/11/30/Python网络爬虫（一）/","link":"","permalink":"http://github.com/hzebin/2019/11/30/Python网络爬虫（一）/","excerpt":"","text":"Python网络爬虫requests库 自动爬取HTML页面，自动网络请求提交 123456789requests库的安装小测：#导入requests库import requests#构造一个请求r = requests.get(\"https://baidu.com\")print(\"r的类型为：\\n\", type(r))print(\"状态码为：\\n\", r.status_code)print(\"html内容为：\\n\", r.text) requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post() 向HTML页面提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE 12345678910requests.get()r = requests.get(url)构造一个向服务器请求资源的Request对象返回一个包含服务器资源的Response对象，Response对象包含爬虫返回的内容requests.get(url, params=None, **kwargs)url 拟获取页面的URL链接params url中的额外参数，字典或字节流格式，可选**kwargs 12个控制访问的参数 Response对象的属性 属性 说明 r.status_code HTTP请求的返回状态，200表示连接成功，404或其他表示失败 r.text HTTP响应内容的字符串形式，即URL对应的页面内容 r.encoding 从HTTP header中猜测响应内容的编码方式（查看的的头部的charset，不准确，默认编码为ISO‐8859‐1） r.apparent_encoding 从内容中分析出响应内容的编码方式（备选编码方式，比较准确） r.content HTTP响应内容的二进制形式（例如图像） 12345678910111213#导入requests库import requests#构造一个请求r = requests.get(\"https://baidu.com\")print(\"r的类型为：\\n\", type(r))#查看是否请求成功print(\"状态码为：\\n\", r.status_code)print(\"html内容为：\\n\", r.text)print(\"网页的编码方式为：\\n\", r.encoding)print(\"网页的备选编码方式为：\\n\", r.apparent_encoding)#设置网页的编码方式r.encoding = 'utf-8'print(\"html内容为：\\n\", r.text) requests.get()网络连接可能有风险会抛出异常 requests库的异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败，拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequired URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status() 如果不是200，产生异常requests.HTTPErrot。在方法内部判断r.status_code是否等于200，不需要增加额外的if语句，该语句便于利用try-except进行异常处理。 123456789101112131415161718爬取网页的通用代码框架#爬取网页的通用代码框架import requestsdef getHTMLText(url): try: r = requests.get(url, timeout = 30) r.raise_for_status() #如果状态不是200，英法HTTPError异常 r.encoding = r.apparent_encoding return r.text except: return \"产生异常\"if __name__ == \"__main__\": url = \"https://www.baidu.com\" print(getHTMLText(url)) HTTP 超文本传输协议 HTTP是一个基于“请求与响应”模式的、无状态【第一次请求与第二次请求没有关联】的应用层协议【HTTP协议工作在TCP协议之上】。采用URL作为定位网络资源的标识，URL格式如下： 1http://host[:port][path] PATCH与PUT的区别 假设URL位置有一组数据UserInfo，包括UserId、UserName等20个字段 需求：用户修改了UserName，其他不变 采用PATCH，仅向URL提交UserName的局部更新请求 采用PUT，必须将所有20个字段一并提交到URL，未提交的字段将会被删除 PATCH优点：节省网络宽带 1234567#requests库的head()方法import requestsr = requests.head(\"https://baidu.com\")print(\"请求的头部内容为：\\n\", r.headers)print(\"请求的html内容为：\\n\", r.text) #输出为空#所用head可以更加节约网络资源地去获取网络概要信息 1234567891011121314#requests库的post()方法import requestspayload = &#123;'key1': 'value1', 'key2': 'value2'&#125; #字典 键值对r = requests.post('http://httpbin.org/post', data = payload)print(r.text)## 向URL POST一个字典，自动编码为from表单 跟put()方法一样，不过会将原有地数据覆盖掉# &#123; ... # \"form\": &#123; # \"key2\": \"value2\", # \"key1\": \"value1\" # &#125;, # ...# &#125; 123456789101112#requests库地post()方法import requestsr = requests.post('http://httpbin.org/post', data = 'ABC') #字符串print(r.text)## 向URL POST一个字符串，自动编码为data# &#123;# ...# \"data\": \"ABC\",# \"form\": &#123;&#125;,# ...# &#125; 1234567891011121314151617181920212223242526272829303132requests.requests(method, url, **kwargs)method 请求方式，对应有GET/HEAD/POST/PUT/PATCH/DELETE/OPTIONS（获取服务器跟客户端能够打交道的参数）一共7种url 拟获取页面的url链接**kwargs 访问控制的参数，共13个，可选项 params 字典或字节序列，作为参数增加到url中 &gt;&gt;&gt; kv=&#123;'key1':'value1','key2':'value2'&#125; &gt;&gt;&gt; r=requests.request('GET','http://python123.io/ws',params=kv) &gt;&gt;&gt; print(r.url) http://python123.io/ws?key1=value1&amp;key2=value2 data 字典、字节序列或文件对象，作为Requests的内容 &gt;&gt;&gt; kv=&#123;'key1':'value1','key2':'value2'&#125; &gt;&gt;&gt; r=requests.request('POST','http://python123.io/ws',data=kv) &gt;&gt;&gt; body='主体内容' &gt;&gt;&gt; r=requests.request('POST','http://python123.io/ws',data=body) json JSON格式的数据，作为Requests的内容 &gt;&gt;&gt; kv=&#123;'key1':'value1'&#125; &gt;&gt;&gt; r=requests.request('POST','http://python123.io/ws',json=kv) headers 字典，HTTP定制头 &gt;&gt;&gt; hd=&#123;'user‐agent':'Chrome/10'&#125; &gt;&gt;&gt; r=requests.request('POST','http://python123.io/ws',headers=hd) cookies 字典或CookieJar,Requests中的cookie auth 元组，支持HTTP认证功能 files 字典类型，传输文件 &gt;&gt;&gt; fs=&#123;'file':open('data.xls','rb')&#125; &gt;&gt;&gt; r=requests.request('POST','http://python123.io/ws',files=fs) timeout 设定超时时间，秒为单位 &gt;&gt;&gt; r=requests.request('GET','http://www.baidu.com',timeout=10) proxies 字典类型，设定访问代理服务器，可以增加登录认证(可以隐藏源，防止逆追踪) &gt;&gt;&gt; pxs=&#123;'http':'http://user:pass@10.10.10.1:1234' 'https':'https://10.10.10.1:4321'&#125; &gt;&gt;&gt; r=requests.request('GET','http://www.baidu.com',proxies=pxs) allow_redirects True/False，默认为True，重定向开关 stream True/False，默认为True，获取内容立即下载开关 verify True/False，默认为True，认证SSL证书开关 cert 本地SSL证书路径","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://github.com/hzebin/tags/爬虫/"}]},{"title":"jQuery学习笔记（三）","slug":"jQuery学习笔记（三）","date":"2019-09-23T00:25:27.000Z","updated":"2019-09-26T15:16:22.494Z","comments":true,"path":"2019/09/23/jQuery学习笔记（三）/","link":"","permalink":"http://github.com/hzebin/2019/09/23/jQuery学习笔记（三）/","excerpt":"","text":"jQuery操作DOM 操作元素样式获取样式属性值jQuery中通过css()方法获取样式属性值 语法://获取单个属性：$(selector).css(‘property’);返回结果是字符串形式的属性值 //获取多个属性$(selector).css([‘property1’, ‘property2’, ‘property3’, …]);返回结果是对象形式的属性名和属性值 设置样式属性值jQuery中通过css()方法设置样式属性值 语法：//设置单个属性$(selector).css(‘property’, ‘value’); //设置多个属性$(selector).css({‘property1’: ‘value1’, ‘property2’: ‘value2’, …}); 12345678910111213141516171819202122232425&lt;body&gt; &lt;div style=\"color: red; font-size: 50px; font-family: '宋体'\"&gt; 越努力 越幸运 &lt;/div&gt; &lt;input id=\"myBtn\" type=\"button\" value=\"设置样式\"/&gt; &lt;div id=\"d1\"&gt;&lt;/div&gt; &lt;script&gt; //获取样式属性值--单个属性 var a = $('div').css('color'); console.log(a); //结果为rgb(255, 0, 0) //获取样式属性值--多个属性 var obj = $('div').css(['color', 'font-size', 'font-family']); console.log(obj); //结果为&#123;color: \"rgb(255, 0, 0)\", font-size: \"50px\", font-family: \"宋体\"&#125; //设置样式属性--单个属性 //设置样式属性--多个属性 $('#myBtn').click(function() &#123; $('#d1').css(&#123;background: 'pink', width: '150px', height: '150px', 'border-radius': '50%'&#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 通过函数设置样式属性值使用css()方法设置属性值时，每个样式属性对应的value值还可以替换为函数形式。 语法：函数调用后，将返回值作为样式属性的值。index表示匹配元素的索引值，从0开始；value表示匹配元素的样式属性的当前值；newValue表示函数的返回值。 1234567891011121314//设置单个属性$(selector).css('property', function(index, value) &#123; return newValue;&#125;);//设置多个属性$(selector).css(&#123; 'property1': function(index, value1) &#123; return newValue; &#125;, 'property2': function(index, value2) &#123; return newValue; &#125;&#125;); 12345678910111213141516171819202122232425&lt;body&gt; &lt;input id=\"myBtn\" type=\"button\" value=\"设置样式\"/&gt; &lt;div&gt;&lt;/div&gt; &lt;div id=\"d2\"&gt;&lt;/div&gt; &lt;script&gt; $('div').css(&#123;background: 'pink', width: '150px', height: '50px', 'border-radius': '50%'&#125;); //通过函数设置样式 $('#myBtn').click(function() &#123; $('div').css(&#123; width: function(index, value) &#123; return parseFloat(value) * 2; &#125;, height: function(index, value) &#123; if(index === 1)&#123; return parseFloat(value) * 2; &#125; &#125; &#125;); &#125;); console.log($('#d2').css('width')); &lt;/script&gt;&lt;/body&gt; jQuery操作元素类 方法 描述 addClass() 将指定的类添加到匹配元素中 removeClass() 从所有匹配的元素中删除全部或指定的类 toggleClass() 对设置或移除被选元素的一个或多个类进行切换 hasClass() 判断元素的某个类是否存在 在实际开发中，css()方法与addClass()、removeClass()方法虽然可以改变元素的样式，但使用场景不同。一般来说，为了分离CSS与Javascript代码，建议使用addClass()、removeClass()对类进行操作，通过增加和移动类来实现样式的切换。而css()方法适用CSS样式值不固定的情况，例如为元素随机生成背景色。 toggleClass()方法：$(selector).toggleClass(‘c’); //参数c表示一个自定义的类，调用toggleClass()方法，指定元素中若没有c，则添加，否则执行移除操作。 方式一： 1234567891011121314151617181920&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $('div').addClass('c'); //添加单个类 $('div').addClass('c1 c2 c3'); //添加多个类（用空格分开） $('div').removeClass(); //移除所有类 $('div').removeClass('c'); //移除单个类 $('div').removeClass('c1 c2 c3'); //移除多个类 var d = $('div'); d.toggleClass('c'); //第一次调用 console.log(d[0].outerHTML); //&lt;div class=\"c\"&gt;&lt;/div&gt; d.toggleClass('c'); //第二次调用 console.log(d[0].outerHTML); //&lt;div class=\"\"&gt;&lt;/div&gt; d.toggleClass('c'); //第三次调用 console.log(d[0].outerHTML); //&lt;div class=\"c\"&gt;&lt;/div&gt; &lt;/script&gt;&lt;/body&gt; 方式二：toggleClass()的第二个参数，可手动控制类的添加或移除。该参数是布尔值，true表示添加类，false表示移除类。 12$(selector).toggleClass('c', true); //添加类c$(selector).toggleClass('c', false); //删除类c 方式三：toggleClass()第二个参数可通过条件判断的返回值设置。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;操作元素类&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; .b &#123; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;12312313&lt;/div&gt; &lt;script&gt; d.toggleClass('c', true); console.log(d[0].outerHTML); var count=0; $('div').click(function() &#123; //this表示发生事件的元素 $(this).toggleClass('b', ++count%3 === 0); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拓展：操作元素类的addClass()、removeClass()、toggleClass()方法支持使用函数作为参数，通过参数的返回值来操作元素的类。 123456//addClass()方法$('div').addClass(function(index, value) &#123; console.log('元素的索引：' + index); console.log('元素原来的class值' + value); return 'item-' + index; //将返回值作为要添加的class&#125;); hasClass()方法：$(selector).hasClass(‘c’); //判断是否含有类名c 12345678910111213141516//判断是否含有类名c，有则移除，无则添加&lt;body&gt; &lt;div&gt;Huang Zebin&lt;/div&gt; &lt;script&gt; $('div').click(function() &#123; if($('div').hasClass('c')) &#123; $('div').removeClass('c'); &#125; else &#123; $('div').addClass('c'); &#125; var result = $('div'); console.log(result[0].outerHTML); &#125;); &lt;/script&gt;&lt;/body&gt; 操作元素的尺寸 方法 描述 width() 获取或设置元素的宽度 （没包括内边距？？） height() 获取或设置元素的高度 innerWidth() 获取元素的宽度（包括内边距） innerHeight() 获取元素的高度（包括内边距） outerWidth() 获取元素的宽度（包括内边距和边框） outerHeight() 获取元素的高度（包括内边距和边框） outerWidth(true) 获取元素的宽度（包括内边距、边框、外边距） outerHeight(true) 获取元素的高度（包括内边距、边框、外边距） 123$(selector).width(); //获取宽度$(selector).width('30px'); //设置宽度$(selector).width(30); //设置宽度，不加引号不能添加单位 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 200px; /*元素的宽高（文字）*/ height: 200px; background: yellow; color: red; /*字体颜色*/ text-align: center; border-radius: 25%; line-height: 25px; padding: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 获取和设置元素的宽度和高度 --&gt; &lt;input type=\"button\" value=\"按钮\"/&gt; &lt;div&gt;Huang Zebin&lt;/div&gt; &lt;script&gt; $('input').click(function() &#123; $('div').width($('div').width() + 50); $('div').height($('div').height() + 50); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 备注：会查看Chrome的盒子模型 操作元素的位置 方法 描述 offset() 获取匹配元素的（第一个元素）的坐标位置，或设置每个元素的坐标 offsetParent() 获取距离匹配元素最近的（含有定位信息）的元素 position() 获取匹配元素相对父元素的偏移 scrollLeft() 获取或设置匹配元素相对滚动条左侧的偏移 scrollTop() 获取或设置匹配元素相对滚动条顶部的偏移 offset()方法：可以获取到匹配元素中的第一个元素在当前页面的坐标位置。若元素的样式属性display设置为none，则获取到的值为0。语法： $(selector).offset();返回值包含两个属性left和top，分别表示元素距离浏览器的左偏移和上偏移。 12345678910111213&lt;body&gt; &lt;div&gt;offset()&lt;/div&gt; &lt;script&gt; //获取div的top和left值 console.log($('div').offset().top); console.log($('div').offset().left); //设置div的top和left值 //$('div').offset(&#123;left: 200, top: 100&#125;); $('div').offset(&#123;left: 100&#125;); //键值对&#123;&#125; 向右偏移 &lt;/script&gt;&lt;/body&gt; position()方法获取元素相对于父元素（含有定位）的偏移，当父元素没有设置定位时，后者的左右与前者等价.【例子？？】 offsetParent()方法返回距离指定元素最近的“被定位”的祖辈元素对象。“被定位”是指元素的样式属性中position属性的值为relative、absolute、fixed，不包括position属性的默认值static。语法： $(selector).offsetParent(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; border: 1px solid red; &#125; #d1 &#123; width: 100px; height: 100px; &#125; #d2 &#123; width: 200px; height: 200px; &#125; #d3 &#123; width: 300px; height: 300px; &#125; #d4 &#123; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"d1\"&gt; &lt;div id=\"d2\" style=\"position: relative\"&gt; &lt;div id=\"d3\"&gt; &lt;div id=\"d4\"&gt;test&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $('#d4').offsetParent().css('backgroundColor', 'green'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; scrollLeft()与scrollTop()方法可以获取或设置指定元素相对滚动条左侧和顶部的偏移值。//获取元素相对左侧的偏移值$(selector).scrollLeft();//设置元素相对左侧的偏移值$(selector).scrollLeft(value); 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; background: pink; height: 100px; width: 200px; border: 1px solid black; overflow: auto; &#125; p &#123; background: yellow; height: 1000px; width: 1000px; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"按钮\"/&gt; &lt;div&gt; &lt;p&gt;行动好过语言&lt;/p&gt; &lt;/div&gt; &lt;script&gt; $('input').click(function() &#123; $('div').scrollTop('500'); $('div').scrollLeft('50'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://github.com/hzebin/tags/jQuery/"}]},{"title":"jQuery学习笔记（二）","slug":"jQuery学习笔记（二）","date":"2019-09-22T05:00:00.000Z","updated":"2019-09-22T14:27:36.169Z","comments":true,"path":"2019/09/22/jQuery学习笔记（二）/","link":"","permalink":"http://github.com/hzebin/2019/09/22/jQuery学习笔记（二）/","excerpt":"","text":"jQuery选择器简介选择器的应用体现了jQuery的一个设计思想，即获取（选择）网页中的元素，然后根据实际需求对元素进行各种操作。 jQuery模仿CSS选择器实现了jQuery选择器，然后通过jQuery选择器来获取元素，不仅让获取元素的方式更加多样化，而且可以在获取元素后为元素添加样式、行为。 jQuery选择器语法： $(selector);//根据id值获取元素$(‘#id的值’)//根据元素的名称获取元素$(‘元素的名称’)selector代表jQuery选择器，代码执行后，返回一个jQuery对象（类数组）。 jQuery选择器按照功能可以分为基本选择器、层次选择器、过滤选择器。 基本选择器基本选择器包括id选择器、类选择器。元素选择器、通配符选择器。 选择器 描述 返回值 #id id选择器，根据id值匹配一个元素 单个元素 .class 类选择器，根据类名匹配元素 元素集合 element 元素选择器，根据元素名匹配所有元素 元素集合 * 通配符选择器，匹配所有元素 元素集合 selector1, selector2, …, selectorN 同时获取多个元素 元素集合 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;基本选择器&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"byId\"&gt;第一个div元素，id值为byId&lt;/div&gt; &lt;p&gt;第一个p元素&lt;/p&gt; &lt;p class=\"byClass\"&gt;第二个p元素，类名为byClass&lt;/p&gt; &lt;div class=\"byClass\"&gt;第二个div元素，类名为byClass&lt;/div&gt; &lt;script&gt; //id选择器,一个id选择器只能获取一个元素 $('#byId').css('background', 'pink'); //修改背景颜色 //类选择器,可以为不同的元素设置同名的class值 $('.byClass').css('background', 'red'); //元素选择器 $('p').css('font-size', '20px'); //通配符选择器(*获取页面的所有元素,包括body元素，有性能问题) $('*').css('background', 'yellow'); /* 虽然通配符可以匹配所有的元素，但是会影响网页渲染的时间，建议用逗号分隔开多个元素 $('.byClass, #byId').css('background', 'yellow'); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 层次选择器 选择器 描述 返回值 parent &gt; child 子元素选择器，根据父元素匹配所有的子元素（紧邻的一代元素） 元素元素 selector selector1 后代选择器，根据祖先元素（selector）匹配所有的后代元素（selector1）。【后代元素不仅包括子元素，还包括子元素下的所有其他元素】 元素集合 prev + next 兄弟选择器，匹配prev元素紧邻的兄弟元素【后面第一个符合的元素，只找一个，包括* 】 元素集合 prev ~ siblings 兄弟选择器，匹配prev元素后的所有兄弟元素 元素集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;层次选择器&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是div前面的p元素&lt;/p&gt; &lt;div id=\"dv\"&gt; &lt;p&gt;这是div中的第一个p元素&lt;/p&gt; &lt;ul&gt; &lt;li&gt;这是第一个li元素&lt;/li&gt; &lt;li&gt;&lt;p&gt;这是第二个li中的p元素&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;这是div中的第二个p元素&lt;/p&gt; &lt;/div&gt; &lt;p&gt;这是div后面的第1个p元素&lt;/p&gt; &lt;p&gt;这是div后面的第2个p元素&lt;/p&gt; &lt;p&gt;这是div后面的第3个p元素&lt;/p&gt; &lt;script&gt; //子元素选择器// $('#dv &gt; p').css('background', 'red'); //在jQuery中，可以使用children()方法代替子元素的选择器 /* $('#dv &gt; p'); //使用子元素选择器获取 $('#dv').children('p'); //使用children方法获取 另： $('#dv &gt; *'); //找出id为dv下的全部子元素 */ //后代选择器// $('#dv p').css('background', 'red'); /* find()方法也可以获取指定元素的后代元素 $('#dv p'); //使用后代选择器获取 $('#dv').find('p'); //使用find()方法获取 */ //兄弟选择器// $('#dv + p').css('background', 'green'); //兄弟选择器// $('#dv ~ p').css('background', 'yellow'); /* 拓展： next()可获取指定元素紧邻的下一个兄弟元素 $('div').next('p').css('background', 'green'); nextAll()可获取指定元素后的所有兄弟元素 $('div').nextAll('p').css('background', 'green'); siblings()可获取指定元素的所有兄弟元素（前后都要） $('div').siblings('p').css('background', 'green'); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 过滤选择器为了快速筛选DOM元素，jQuery提供了一些过滤选择器，过滤选择器通常以“：”开头，”：“后面用于指定过滤规则。 以下介绍7种过滤选择器 基本过滤选择器 选择器 描述 返回值 :first 获取第一个元素 单个元素 :last 获取最后一个元素 单个元素 :not(selector) 获取除给定选择器外的所有元素 元素集合 :even 获取所有索引值为偶数的元素，索引号从0开始 元素集合 :odd 获取所有索引值为奇数的元素，索引号从0开始 元素集合 :eq(index) 指定元素索引值元素 单个元素 :gt(index) 大于所给定值的元素 元素集合 :lt(index) 小于给定值的元素 元素集合 :header 获取所有标题类型的元素，如h1,h2,… 元素集合 :animated 获取正在执行动画效果的元素 元素集合 1234567891011121314151617&lt;body&gt; &lt;ul style=\"width: 200px\"&gt; &lt;li&gt;第一行&lt;/li&gt; &lt;li&gt;第二行&lt;/li&gt; &lt;li&gt;第三行&lt;/li&gt; &lt;li&gt;第四行&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //索引值为偶数的li $('li:even').css('background', 'pink'); //索引值为奇数的li $('li:odd').css('background', 'red'); //索引值大于等于2的li (可以使用组合形式) $('li:eq(2), li:gt(2)').css('background', \"green\"); &lt;/script&gt;&lt;/body&gt; 可见性过滤选择器在网页开发中，具有动态效果的页面往往有很多元素被隐藏。”:hidden”选择器可以获取css样式为”display: none”，以及属性” type=”hidden” “的文本隐藏域。 选择器 描述 返回值 :visible 获取所有可见元素 元素集合 :hidden 获取所有不可见元素 元素集合 123456789101112131415161718192021&lt;body&gt; &lt;p id=\"dis\"&gt;显示文本1&lt;/p&gt; &lt;p id=\"vis\"&gt;显示文本2&lt;/p&gt; &lt;input type=\"hidden\" value=\"隐藏文本\"/&gt; &lt;script&gt; //获取所有课件元素，添加背景色 $(':visible').css('background', 'yellow'); console.log($(':visible')); //获取显示的p元素，设置两种不同的隐藏方式 //备注：\":hidden\"选择器无法获取CSS样式为\"visibility: hidden\"的隐藏元素 $('#dis:visible').css('display', 'none'); //空间释放 $('#vis:visible').css('visibility', 'hidden'); //空间不释放 console.log('隐藏的p元素：'); console.log($('p:hidden')); console.log('隐藏的input元素：'); console.log($('input:hidden')); &lt;/script&gt;&lt;/body&gt; 内容过滤选择器元素的内容是指它所包含的子元素或文本内容 选择器 描述 返回值 :contains(text) 获取包含给定文本的元素 元素集合 :empty 获取所有不包含子元素或者文本的空元素 元素集合 :has(selector) 获取含有选择器所匹配的元素 元素集合 :parent 获取含有子元素或文本的元素 元素集合 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;过滤选择器--内容过滤选择器&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 200px; height: 30px; margin: 5px; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是div元素的文本&lt;/div&gt; &lt;div&gt;我也是div元素的文本&lt;/div&gt; &lt;div&gt;&lt;span&gt;我是div内span元素的文本&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; //查找含有“也”子的元素 $('div:contains(\"也\")').css('background', 'pink'); //查找含有span标签的元素 $('div:has(span)').css('background', 'pink'); //查找为空的div元素 $('div:empty').css('background', 'pink'); //内容不为空的元素 $('div:parent').css('background', 'green'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 属性过滤选择器 选择器 描述 返回值 [attribute] 获取包含给定属性的元素 元素集合 [attribute=value] 获取等于给定的属性是某个特定值的元素 元素集合 [attribute!=value] 获取不等于给定的属性是某个特定值的元素 元素集合 [attribute^=value] 获取给定的属性是以某些值开始的元素 元素集合 [attribute$=value] 获取给定的属性是以某些值结尾的元素 元素集合 [attribute*=value] 获取给定的属性是以包含某些值的元素 元素集合 [selector1][selector2][selectorN] 获取满足多个条件的复合属性的元素（并且关系） 元素集合 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;过滤选择器--属性过滤选择器&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 200px; height: 50px; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"dv\"&gt;class=dv&lt;/div&gt; &lt;div title=\"标题\"&gt;title=标题&lt;/div&gt; &lt;div class=\"dv1\" title=\"标题1\"&gt;class=dv1 title=标题1&lt;/div&gt; &lt;div class=\"dv1\" title=\"标题2\"&gt;class=dv2 title=标题2&lt;/div&gt; &lt;script&gt; //获取所有（可以在[]前添加指定标签）class属性值以d开头的元素 $('[class^=d]').css('background', 'pink'); //获取所有class=dv1，title属性值含有2的元素 $('[class=dv1][title*=2]').css('background', 'green'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 子元素过滤选择器 选择器 描述 返回值 :first-child 获取每个父元素下的第一个子元素 元素集合 :last-child 获取每个父元素下的最后一个子元素 元素集合 :only-child 获取每个仅有一个子元素的父元素下的子元素 元素集合 :nth-child(eq、even、odd、index) 获取每个元素下的特定元素，索引号从1开始 元素集合 123456789101112131415161718192021222324&lt;body&gt; &lt;ul&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;广州&lt;/li&gt; &lt;li&gt;深圳&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;天津&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;重庆&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //获取父元素下仅含一个的子元素 $('li:only-child').css('background', 'pink'); //获取元素指定元素下的第一个元素 $('li:nth-child(1)').css('background', 'green'); &lt;/script&gt;&lt;/body&gt; 表单过滤选择器 选择器 描述 返回值 :input 获取表单中所有input、textarea、select、button元素（表单控件） 元素集合 :text 获取表单中所有input[type=text]的元素（单行文本框） 元素集合 :password 获取表单中所有input[type=password]的元素（密码框） 元素集合 :radio 获取表单中所有input[type=radio]的元素（单选按钮） 元素集合 :checkbox 获取表单中所有input[type=checkbox]的元素（复选框） 元素集合 :submit 获取表单中所有input[type=submit]的元素（提交按钮） 元素集合 :image 获取表单中所有input[type=image]的元素（图像域） 元素集合 :reset 获取表单中所有input[type=reset]的元素（重置按钮） 元素集合 :button 获取表单中所有input[type=button]的元素（普通按钮） 元素集合 :file 获取表单中所有input[type=file]的元素（文件域） 元素集合 注意：①”:button”选择器的作用范围，包含使用input[type=button]和button元素定义的按钮②”:image”选择器的作用范围，包含使用input[typeimage]定义的图像，但不包含img元素定义的图像 123456789101112131415161718192021222324&lt;body&gt; &lt;form id=\"myForm\"&gt; 昵称：&lt;input type=\"text\" value=\"text\"/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" value=\"password\"/&gt;&lt;br/&gt; 性别：&lt;input type=\"radio\"&gt;&lt;span&gt;男&lt;/span&gt;&lt;input type=\"radio\"&gt;&lt;span&gt;女&lt;/span&gt;&lt;br/&gt; 爱好：&lt;input type=\"checkbox\"&gt;&lt;span&gt;游泳&lt;/span&gt;&lt;input type=\"checkbox\"&gt;&lt;span&gt;旅游&lt;/span&gt;&lt;br/&gt; 照片1：&lt;img src=\"./img/pro_down.png\" width=\"100\"&gt;&lt;br/&gt; 照片2：&lt;input type=\"image\" src=\"./img/pro_down.png\" width=\"150\"&gt;&lt;br/&gt; 说明：&lt;textarea&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;button&gt;清空&lt;/button&gt; &lt;input type=\"button\" value=\"保存\"/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;script&gt; //隐藏button定义的按钮 //$('#myForm :button').hide(); //!!!!#myForm后面有空格，等价于#myForm *:button //隐藏input定义的图片 $('#myForm :image').hide(); //不包含img元素 &lt;/script&gt;&lt;/body&gt; 表单对象属性过滤选择器 选择器 描述 返回值 :enabled 获取表单中所有属性为可用的元素 元素集合 :disabled 获取表单中所有属性为不可用的元素 元素集合 :checked 获取表单中所有被选中的元素 元素集合 :selected 获取表单中所有被选中的option的元素 元素集合 1$('input:checked').hide(); //隐藏选中的元素","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://github.com/hzebin/tags/jQuery/"}]},{"title":"Jquery学习笔记（一）","slug":"jQuery学习笔记（一）","date":"2019-09-22T03:42:00.000Z","updated":"2019-09-22T03:42:28.539Z","comments":true,"path":"2019/09/22/jQuery学习笔记（一）/","link":"","permalink":"http://github.com/hzebin/2019/09/22/jQuery学习笔记（一）/","excerpt":"","text":"什么是jQueryjQuery是一款跨浏览器的开源JavaScript库，它的核心理念是write less,do more（写得更少，做的更多）。 jQuery 1.x版本兼容IE6/7/8，使用最为广泛，所以推荐使用1.x最新版本(官网地址：https://code.jquery.com/) DOM对象与jQuery对象什么是DOM对象在Javascript中，经常需要操作DOM。所谓DOM指的是文档对象模型。它提供了对文档结构化的描述，并将HTML页面与脚本、程序语言联系起来. 什么是jQuery对象$()是一个工厂函数，通过$(参数)的形式可以创建jQuery的实例对象，创建了jQuery对象之后，可以调用提供的方法。备注：$(参数)等价于jQuery(参数)，若在项目中$被用于其他功能，则可使用jQuery进行操作。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jQuery对象&lt;/title&gt; &lt;script src=\"./js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;!--引入本地jQuery--&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Hello jQuery&lt;/div&gt; &lt;script&gt; //创建div元素对象，保存为obj var obj = $('div'); //判断obj是否为jQuery对象 alert(obj instanceof jQuery); //输出结果为true //调用html()方法获取元素的内容 alert(obj.html()); //输出结果为Hello jQuery &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拓展：在使用jQuery时，不仅可以通过jQuery对象调用实例方法，还可以直接通过“$.方法名()”的形式调用静态方法。静态方法“$.trim()”可以过滤字符串两端的空白字符 jQuery对象转换成DOM对象jQuery对象属于类数组对象，其内部将DOM对象作为数组元素。jQuery对象转换成DOM对象有两种方式，index表示DOM对象在jQuery对象中的索引。方式1：obj[index] 123456789&lt;div&gt;第一个div&lt;/div&gt;&lt;div&gt;第二个div&lt;/div&gt;&lt;script&gt; var divs = $('div') //divs类数组 var div1 = divs[0]; var div2 = divs[1]; alert(div1.innerHTML); alert(div2.innerHTML);&lt;/script&gt; 方式2：obj.get(index) 12345&lt;div&gt;第一个div&lt;/div&gt;&lt;script&gt; var result = $('div').get(0).innerHTML; alert(result);&lt;/script&gt; DOM对象转换成jQuery对象将DOM对象作为$()函数的参数，即可转换成jQuery对象 12345678&lt;button id=\"myBtn\"&gt;Hello HuangZebin&lt;/button&gt;&lt;script&gt; //获取DOM对象myBtn var btn = document.getElementById('myBtn'); //将DOM对象转为jQuery对象 var btn1 = $(btn); //这里不用单引号! alert(btn1[0] === btn); //三等于号（值 类型 都相同）&lt;/script&gt; Chrome开发者工具讲解外链：https://blog.csdn.net/Huang2016SCJ/article/details/101017442","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://github.com/hzebin/tags/jQuery/"}]},{"title":"web学习之javascript","slug":"web学习之javascript","date":"2019-07-14T09:49:00.000Z","updated":"2019-07-14T13:49:52.855Z","comments":true,"path":"2019/07/14/web学习之javascript/","link":"","permalink":"http://github.com/hzebin/2019/07/14/web学习之javascript/","excerpt":"","text":"eg: 20190714C01.jpg eg:外部引入js文件 20190714C02.jpg 我们可以将JavaScript代码放在html文件中任何位置:放在部分,浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。放在部分,JavaScript代码在网页读取到该语句的时候就会执行。 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。 20190714C03.jpg 123456789javascript注释//单行注释/*asasd多行注释asdasd*/ 定义变量使用关键字var,语法如下：var 变量名 123456789101112131415161718变量名可以任意取名，但要遵循命名规则: 1.变量必须使用字母、下划线(_)或者美元符($)开始。 2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。 3.不能使用JavaScript关键词与JavaScript保留字。变量要先声明再赋值，如下：var mychar;mychar=\"javascript\";var mynum = 6;变量可以重复赋值，如下：var mychar;mychar=\"javascript\";mychar=\"hello\";注意:1. 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。2. 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。 JavaScript-判断语句（if…else） 1234567891011121314语法:if(条件)&#123; 条件成立时执行的代码 &#125;else&#123; 条件不成立时执行的代码 &#125;eg:&lt;script type=\"text/javascript\"&gt; var myage = 18; if(myage&gt;=18) //myage&gt;=18是判断条件 &#123; document.write(\"你是成年人。\");&#125; else //否则年龄小于18 &#123; document.write(\"未满18岁，你不是成年人。\");&#125;&lt;/script&gt; javascript函数定义： 12345基本语法如下:function 函数名()&#123; 函数代码;&#125; eg: 20190714C04.jpg JavaScript-输出内容（document.write） 12345678910111213141516171819202122232425document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。第一种:输出内容用\"\"括起，直接输出\"\"号内的内容。&lt;script type=\"text/javascript\"&gt; document.write(\"I love JavaScript！\"); //内容用\"\"括起来，\"\"里的内容直接输出。&lt;/script&gt;第二种:通过变量，输出内容&lt;script type=\"text/javascript\"&gt; var mystr=\"hello world!\"; document.write(mystr); //直接写变量名，输出变量存储的内容。&lt;/script&gt;第三种:输出多项内容，内容之间用+号连接。&lt;script type=\"text/javascript\"&gt; var mystr=\"hello\"; document.write(mystr+\"I love JavaScript\"); //多项内容之间用+号连接&lt;/script&gt;第四种:输出HTML标签，并起作用，标签使用\"\"括起来。&lt;script type=\"text/javascript\"&gt; var mystr=\"hello\";document.write(mystr+\"&lt;br&gt;\");//输出hello后，输出一个换行符 document.write(\"JavaScript\");&lt;/script&gt; 关于空格的eg: 20190714C05.jpg JavaScript-警告（alert 消息对话框） 1234567891011我们在访问网站的时候，有时会突然弹出一个小窗口，上面写着一段提示信息文字。如果你不点击“确定”，就不能对网页做任何操作，这个小窗口就是使用alert实现的。语法: alert(字符串或变量); 看下面的代码:&lt;script type=\"text/javascript\"&gt; var mynum = 30; alert(\"hello!\"); alert(mynum);&lt;/script&gt; JavaScript-确认（confirm 消息对话框） 1234567891011121314151617181920212223confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。语法:confirm(str);参数说明:str：在消息对话框中要显示的文本返回值: Boolean值返回值:当用户点击\"确定\"按钮时，返回true当用户点击\"取消\"按钮时，返回false注: 通过返回值可以判断用户点击了什么按钮看下面的代码:&lt;script type=\"text/javascript\"&gt; var mymessage=confirm(\"你喜欢JavaScript吗?\"); if(mymessage==true) &#123; document.write(\"很好,加油!\"); &#125; else &#123; document.write(\"JS功能强大，要学习噢!\"); &#125;&lt;/script&gt; JavaScript-提问（prompt 消息对话框） 12345678910111213141516171819prompt弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。语法:prompt(str1, str2);参数说明：str1: 要显示在消息对话框中的文本，不可修改str2：文本框中的内容，可以修改返回值:1. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null看看下面代码:var myname=prompt(\"请输入你的姓名:\");if(myname!=null) &#123; alert(\"你好\"+myname); &#125;else &#123; alert(\"你好 my friend.\"); &#125; JavaScript-打开新窗口（window.open） 123456789101112131415161718192021open() 方法可以查找一个已经存在或者新建的浏览器窗口。语法：window.open([URL], [窗口名称], [参数字符串])参数说明:URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。窗口名称：可选参数，被打开窗口的名称。 1.该名称由字母、数字和下划线字符组成。 2.\"_top\"、\"_blank\"、\"_self\"具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。例如:打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：&lt;script type=\"text/javascript\"&gt; window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')&lt;/script&gt;注意：运行结果考虑浏览器兼容问题。 参数表： 20190714C06.jpg JavaScript-关闭窗口（window.close） 1234567891011121314close()关闭窗口用法：window.close(); //关闭本窗口或&lt;窗口对象&gt;.close(); //关闭指定的窗口例如:关闭新建的窗口。&lt;script type=\"text/javascript\"&gt; var mywin=window.open('http://www.imooc.com'); //将新打的窗口对象，存储在变量mywin中 mywin.close();&lt;/script&gt;注意:上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。","categories":[],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://github.com/hzebin/tags/web前端/"}]},{"title":"web学习之css","slug":"web学习之css","date":"2019-07-14T08:34:00.000Z","updated":"2019-07-14T12:48:43.550Z","comments":true,"path":"2019/07/14/web学习之css/","link":"","permalink":"http://github.com/hzebin/2019/07/14/web学习之css/","excerpt":"","text":"CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 eg: 20190714B01.jpg css代码格式： 20190714B02.jpg 1234567多条声明需要用分号分隔&lt;style type=\"text/css\"&gt;p&#123; font-size:12px; /*css的注释语句这样写*/ color:red;&#125;&lt;style&gt; css样式有三种形式：内联式、嵌入式和外部式①内联式 1&lt;p style=\"color:red;font-size:12px\"&gt;这里文字是红色，大小为12px&lt;/p&gt; ②嵌入式 123456789&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;嵌入式css样式&lt;/title&gt;&lt;style type=\"text/css\"&gt;span&#123; /*选择器*/ color:red; /*样式*/&#125;&lt;/style&gt;&lt;/head&gt; ③外部式 12345678连接style.css，样式写在了该文件中&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;嵌入式css样式&lt;/title&gt;&lt;link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; 三种样式的优先级：内联式 &gt; 嵌入式 &gt; 外部式但是嵌入式&gt;外部式有一个前提：嵌入式css样式的位置一定在外部式的后面。如右代码编辑器就是这样，&lt;link href=”style.css” …&gt;代码在…代码的前面（实际开发中也是这么写的）。感兴趣的小伙伴可以试一下，把它们调换顺序，再看他们的优先级是否变化。【其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）】 类选择器 12345678910111213141516语法：.类选器名称&#123;css样式代码;&#125;注意：1、英文圆点开头2、其中类选器名称可以任意起名（但不要起中文噢）使用方法：第一步：使用合适的标签把要修饰的内容标记起来，如下：&lt;span&gt;胆小如鼠&lt;/span&gt;第二步：使用class=\"类选择器名称\"为标签设置一个类，如下：&lt;span class=\"stress\"&gt;胆小如鼠&lt;/span&gt;第三步：设置类选器css样式，如下：.stress&#123;color:red;&#125;/*类前面要加入一个英文圆点*/ eg: 20190714B03.jpg ID选择器 1234在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别：1、为标签设置id=\"ID名称\"，而不是class=\"类名称\"。2、ID选择符的前面是井号（#）号，而不是英文圆点（.） eg: 20190714B04.jpg imooc 8-5 –&gt;go","categories":[],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://github.com/hzebin/tags/web前端/"}]},{"title":"web学习之html","slug":"web学习之html","date":"2019-07-14T08:15:00.000Z","updated":"2019-07-14T08:15:53.413Z","comments":true,"path":"2019/07/14/web学习之html/","link":"","permalink":"http://github.com/hzebin/2019/07/14/web学习之html/","excerpt":"","text":"HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;!--根标签--&gt; &lt;head&gt; &lt;!--文档头部标签--&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;Html和CSS的关系&lt;/title&gt; &lt;style type=\"text/css\"&gt; h1&#123; font-size:12px; color:#930; text-align:center; &#125; &lt;!--css样式--&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--网页显示的主要内容--&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415标签可以大写或小写，但建议为小写&lt;h1&gt;&lt;/h1&gt; 标题标签&lt;p&gt;段落文本&lt;/p&gt; 段落标签 [默认样式：段前段后都会有空白]&lt;img src=\"1.jpg\"&gt; 图片img引用标签&lt;em&gt;&lt;/em&gt; 斜字体，强调关键字&lt;strong&gt;&lt;/strong&gt; 粗字体&lt;p1&gt;&lt;/p2&gt; ... &lt;p6&gt;&lt;/p6&gt; 文章标题 [默认样式：加粗 1到6字体从大到小]&lt;span&gt;文本&lt;/span&gt; 为文字设置单独的样式&lt;br/&gt; 换行&lt;hr/&gt; 水平横线 [默认样式：加粗黑色]&lt;address&gt;联系地址信息&lt;/address&gt; 地址信息标签 [默认样式：斜体 ;可以定义一个地址，如电子邮件地址、签名、文档的作者身份]&lt;code&gt;代码语言&lt;code&gt; 单行代码&lt;pre&gt;代码语言&lt;/pre&gt; 多行代码 [代码会保留空格和换行符]&lt;div&gt;&lt;/div&gt; 可以把一些独立的逻辑部分划分出来，相当于一个容器&amp;nbsp; 空格 1234567891011&lt;head&gt;标签的作用:文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。下面这些标签可用在 head 部分:&lt;head&gt; &lt;title&gt;...&lt;/title&gt; &lt;!--网页的标题信息--&gt; &lt;meta&gt; &lt;link&gt; &lt;style&gt;...&lt;/style&gt; &lt;script&gt;...&lt;/script&gt;&lt;/head&gt; 1&lt;span&gt;&lt;/span&gt;标签 为文字设置单独的样式eg: 20190714A01.jpg 12&lt;q&gt;引用文本&lt;/q&gt;标签短文本引用，引用别人的话，自动为文本两边加上双引号 eg: 20190714A02.jpg 12&lt;blockquote&gt;文本引用&lt;/blockquote&gt;标签对长文本进行引用，引用的文本整段会缩进 20190714A03.jpg 12ul-li标签列表显示标签，没有前后顺序,默认样式每项li前都会自带一个圆点 eg: 20190714A04.jpg ol-li标签列表显示标签，有前后顺序，默认样式每项前有序号，序号从1开始eg: 20190714A05.jpg 123&lt;div&gt;&lt;/div&gt; 标签可以为一个逻辑部分设置一个名称，唯一标识&lt;div id=\"板块名称\"&gt;..&lt;/div&gt; 123456789&lt;table&gt;&lt;/table&gt;标签创建表格的元素有table、tbody、tr(行)、th（表格表头，默认粗体居中）、td(单元格)&lt;tbody&gt;…&lt;/tbody&gt;：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）&lt;table summary=\"表格简介文本\"&gt; 给表格添加摘要摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。&lt;caption&gt;标题文本&lt;/caption&gt; 给表格添加标题用以描述表格内容，标题的显示位置：表格上方。 eg:为表格加入边框 20190714A06.jpg eg:为表格添加摘要和标题 20190714A07.jpg 12345678&lt;a&gt;标签链接到另一个页面&lt;a href=\"目标网址\" title=\"鼠标滑过显示的文本\"&gt;链接显示的文本&lt;/a&gt;只要为文本加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色）设置在新的浏览器窗口中打开&lt;a href=\"目标网址\" target=\"_blank\"&gt;click here!&lt;/a&gt;&lt;a&gt;标签可以利用mailto链接邮件地址 mailto参数详解： 20190714A08.jpg eg:如果mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的参数每一个都以“&amp;”分隔。 20190714A09.jpg 1234&lt;img&gt; 插入图片的标签&lt;img src=\"图片地址\" alt=\"下载失败时的替换文本\" title = \"提示文本\"&gt;1、title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)；2、图像可以是GIF，PNG，JPEG格式的图像文件。 123456789101112131415&lt;form&gt;&lt;/form&gt; 表单标签，与用户交互&lt;form method=\"传送方式\" action=\"服务器文件\"&gt;action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)文本输入框、密码输入框&lt;form&gt; &lt;input type=\"text/password\" name=\"名称\" value=\"文本\" /&gt;&lt;/form&gt;1、type： 当type=\"text\"时，输入框为文本输入框 当type=\"password\"时, 输入框为密码输入框 当type=\"submit\"时, 确定按钮 当type=\"reset\"时, 重置按钮2、name：为文本框命名，以备后台程序ASP 、PHP使用。3、value：为文本输入框设置默认值。(一般起到提示作用) 1234567891011121314&lt;textaarea&gt;&lt;/textarea&gt; 文本域，支持多行文本输入语法：&lt;textarea rows=\"行数\" cols=\"列数\"&gt;文本&lt;/textarea&gt;1、&lt;textarea&gt;标签是成对出现的，以&lt;textarea&gt;开始，以&lt;/textarea&gt;结束。2、cols ：多行输入域的列数。3、rows ：多行输入域的行数。4、在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。eg:&lt;form method=\"post\" action=\"save.php\"&gt; &lt;label&gt;联系我们&lt;/label&gt; &lt;textarea cols=\"50\" rows=\"10\" &gt;在这里输入内容...&lt;/textarea&gt;&lt;/form&gt; 123456789使用单选框、复选框，让用户选择语法：&lt;input type=\"radio/checkbox\" value=\"值\" name=\"名称\" checked=\"checked\"/&gt;1、type: 当 type=\"radio\" 时，控件为单选框 当 type=\"checkbox\" 时，控件为复选框2、value：提交数据到服务器的值（后台程序PHP使用）3、name：为控件命名，以备后台程序 ASP、PHP 使用4、checked：当设置 checked=\"checked\" 时，该选项被默认选中 eg: 20190714A10.jpg 下拉框列表eg: 20190714A11.jpg 12使用下拉列表框进行多选下拉列表也可以进行多选操作，在&lt;select&gt;标签中设置multiple=\"multiple\"属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。 eg: 20190714A12.jpg 1234567form表单中的label标签label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。语法：&lt;label for=\"控件id名称\"&gt;注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 eg: 20190714A13.jpg","categories":[],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://github.com/hzebin/tags/web前端/"}]},{"title":"软件设计师之程序语言基础知识","slug":"软件设计师之程序语言基础知识","date":"2019-03-16T12:46:28.000Z","updated":"2019-03-16T14:36:02.553Z","comments":true,"path":"2019/03/16/软件设计师之程序语言基础知识/","link":"","permalink":"http://github.com/hzebin/2019/03/16/软件设计师之程序语言基础知识/","excerpt":"","text":"基础知识低级语言和高级语言(1)低级语言机器语言和汇编语言称为低级语言。&emsp;&emsp;机器语言指0、1组成的机器指令序列&emsp;&emsp;汇编语言指用符号表示指令的语言&emsp;&emsp;MOV AX,2&emsp;&emsp;MOV BX,3&emsp;&emsp;ADD AX,BX (2)高级语言&emsp;&emsp;高级语言是从人类的逻辑思维角度出发、面向各类应用的程序语言，抽象程度大大提高，需要编译成特定机器上的目标代码才能执行。这类语言与人们使用的自然语言比较接近，大大提高了 程序设计的效率。 编译程序和解释程序&emsp;&emsp;高级语言或汇编语言编写的程序称为源程序，源程序不能直接 在计算机上执行。&emsp;&emsp;如果源程序是汇编语言编写的，则需要一个称为汇编程序 的翻译程序将其翻译成目标程序，然后才能执行。&emsp;&emsp;如果源程序是为高级语言时，这个翻译程序称为编译程序&emsp;&emsp;按源程序中语句的执行顺序，逐条翻译并立即执行相关功 能的处理程序、称为解释程序。 程序的执行方式：1、编译执行：按编译方式在计算机上执行用高级语言编写的 程序，需经过两个阶段：编译阶段，把源程序翻译为目标程序； 运行阶段，真正执行此目标程序。&emsp;&emsp;优点：执行效率高、占用资源小。&emsp;&emsp;缺点：兼容性差。2、解释执行：源程序的每个语句一经解释就立即执行。&emsp;&emsp;优点：可移植性较好、开发速度较快、与用户通信方便。&emsp;&emsp;缺点：效率低。 编译系统基本原理编译程序的工作过程可以分为6个阶段：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成。 ①词法分析阶段输入源程序，对构成源程序的字符串进行扫描和分解，识别 出一个个的单词，删掉无用信息，报告分析时的错误。一个程序语言的基本语法符号分为五类：关键字、标识符、 常量、运算符、界符等词法分析器所输出单词符号常常表示成如下的二元式：(单词种别，单词符号的属性值)描述词法规则通常用：正规式和有限自动机 2、状态转换图状态转换图是状态有限的有向图，用圆圈表示结点状态，结 点之间有向边代表状态转换，有向边上可标记字符，表示前 一状态接受某一个字符之后的状态转移。&emsp;&emsp;下图表示在状态i下的状态转换：&emsp;&emsp;若输入字符为x，则读入x并转换到状态j&emsp;&emsp;若输入字符为y，则读入y并转换到状态k 状态转换图的功能&emsp;&emsp;用于识别一定字符串状态转换图的要求&emsp;&emsp;状态（即结点）个数有限&emsp;&emsp;至少一个初始状态，若干终止状态&emsp;&emsp;每条边上标有字符（也可以是空字符） 状态转换图的表示习惯&emsp;&emsp;初始状态用”○”表示&emsp;&emsp;非终止状态用”○”表示&emsp;&emsp;状态之间的跳转用含有字符的有向边表示&emsp;&emsp;终止状态用”◎”表示&emsp;&emsp;多读进一个字符用”*”表示 3、正规表达式与正规集（定义和运算）状态转换图可以构造词法分析程序，但属于非形式化描述 正规表达式（简称正规式）是词法分析的形式化表示方法。 所谓形式化的方法，是指用一整套带有严格规定的符号体系 来描述问题的方法。&emsp;&emsp;优点：更加清晰和准确 正规式与正规集的递归定义：1、ε和Φ都是字母表∑上的正规式，它们所表示的正规集分别为{ε}和Φ；2、任何a∈∑，a是∑上的一个正规式，它所表示的正规集为{a}；3、仅由有限次使用上述三步骤而得到的表达式才是∑上的正规式。仅由这 些正规式所表示的子集才是∑上的正规集。 正规式定义中“|”读为“或“·”读为“连接”“*”读为”闭包”（即，任意有限次的自重复连接） 程序语言的控制结构–unfinish","categories":[],"tags":[{"name":"软件设计师","slug":"软件设计师","permalink":"http://github.com/hzebin/tags/软件设计师/"},{"name":"程序语言基础知识","slug":"程序语言基础知识","permalink":"http://github.com/hzebin/tags/程序语言基础知识/"}]},{"title":"在MyEclipse开发JSP的初学小知识","slug":"在MyEclipse开发JSP的初学小知识","date":"2019-02-25T12:31:04.000Z","updated":"2019-02-25T14:46:59.477Z","comments":true,"path":"2019/02/25/在MyEclipse开发JSP的初学小知识/","link":"","permalink":"http://github.com/hzebin/2019/02/25/在MyEclipse开发JSP的初学小知识/","excerpt":"","text":"外挂Tomcat服务器如果没有MyEclipse编译器，如何浏览JSP项目呢？通过Tomcat软件就可以浏览MyEclipse导出的.war项目 从MyEclipse导出项目右击项目 -&gt; Export -&gt; WAR file 20180225_2_A Tomcat服务器将Tomcat下载到D:\\apache-tomcat-9.0.14 ， 则该目录为Tomcat的安装路径 20180225_2_B conf下的server.xml文件可以配置Tomcat的端口号 20180225_2_C 双击startup.bat可以启动Tomcat服务器 20180225_2_D webapps文件夹内存放的是项目的地方，将导出的homework.war文件粘贴的这个位置，则就是讲这个JSP项目部署到Tomcat服务器中了 20180225_2_E 打开浏览器输入正确的端口号和项目路径，可以浏览到项目的内容 20180225_2_F 双击shutdown.bat可以关闭Tomcat服务器 20180225_2_G 服务器上编译的文件存放在这个位置 20180225_2_H","categories":[],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://github.com/hzebin/tags/MyEclipse/"},{"name":"JSP Web","slug":"JSP-Web","permalink":"http://github.com/hzebin/tags/JSP-Web/"}]},{"title":"初学在MyEclipse下开发JSP页面","slug":"初学在MyEclipse下开发JSP页面","date":"2019-02-25T11:35:56.000Z","updated":"2019-02-25T14:47:04.220Z","comments":true,"path":"2019/02/25/初学在MyEclipse下开发JSP页面/","link":"","permalink":"http://github.com/hzebin/2019/02/25/初学在MyEclipse下开发JSP页面/","excerpt":"","text":"新建JSP Web项目依次操作：File -&gt; New -&gt; Web Projects 20190225A 依次操作：Next -&gt; Next 20190225B 点击finish完成项目的创建 项目结构图如下 20190225C 修改index.jsp文件的代码，第一行修改为pageEncoding=”UTF-8” 20190225D 在下方的Servers选项卡中，点击右边图标，将需要部署的项目进行部署（add and remove) 20190225E 将项目homework添加到服务器完成部署 20190225F 20190225G 点击启动Tomcat服务器 20190225H Console选项卡显示启动服务器的结果，http-8080表示服务器端口 20190225I 在浏览器中输入正确的端口号和路径浏览jsp网页 20190225J 在serverxml文件中可以修改项目的端口号 20190225K","categories":[],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://github.com/hzebin/tags/MyEclipse/"},{"name":"JSP Web","slug":"JSP-Web","permalink":"http://github.com/hzebin/tags/JSP-Web/"}]},{"title":"如何在Eclipse配置Tomcat服务器及创建Java Web项目","slug":"如何在Eclipse配置Tomcat服务器及创建Java Web项目","date":"2019-02-10T13:43:55.772Z","updated":"2019-02-10T14:54:05.861Z","comments":true,"path":"2019/02/10/如何在Eclipse配置Tomcat服务器及创建Java Web项目/","link":"","permalink":"http://github.com/hzebin/2019/02/10/如何在Eclipse配置Tomcat服务器及创建Java Web项目/","excerpt":"","text":"配置前的准备1.通过Tomcat官网链接 http://tomcat.apache.org/ 下载合适的Tomcat2.安装好Eclipse Jee Neon3.配置好Java的JDK，新建Eclipse的workplace 在Eclipse Jee中配置Tomcat点击上边栏Window里的Preferences选项，出现下图 选择Server -&gt; Runtime Environments -&gt; add，出现下图 选择你下载的Tomcat的服务器版本，点击next 选择好下载的Tomcat的文件的目录，点击finish，点击ok在下面的Servers选项卡点击蓝色的英文 选择下载的Tomcat版本并点击finish 出现下图显示的Tomcat服务器并双击它 我这里更改了服务器访问的端口为8888选择Use Tomcat…..如下图 之后保存文件鼠标右击服务器并点击start 当Tomcat服务器显示started时，Tomcat服务器已经启动打开浏览器输入localhost:8888 (端口已设置为8888），出现Tomcat的所示页面则表明Tomcat配置完成，如下图 新建JSP Web项目在eclipse左侧空白处，右键选择New-&gt;Dynamic Web Project（或者左上角File-&gt;New-&gt;Dynamic Web Project）。若New的选择列表中没有Dynamic Web Project，则选择Others，然后输入dynamic（一般输入dy就可以），选择Dynamic Web Project。出现如下图 选择好之后点击next -&gt; next如下所示 修改根目录文件名为WebRoot，下面打勾，最后点击finish此时项目创建完毕，结果如下图的项目文件结构： jsp项目需要写在WebRoot文件夹内，右击WebRoot添加Jsp File文件并编辑代码 右击Tomcat服务器选择Add and Remove，将Hello项目向右部署到服务器 右击启动start Tomcat服务器或restart在浏览器输入正确的URL则可以看到部署的JSP网页","categories":[],"tags":[{"name":"JSP Web","slug":"JSP-Web","permalink":"http://github.com/hzebin/tags/JSP-Web/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://github.com/hzebin/tags/Tomcat/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://github.com/hzebin/tags/Eclipse/"}]},{"title":"Centos下Nginx安装与配置","slug":"Centos下Nginx安装与配置","date":"2019-01-30T10:19:06.000Z","updated":"2019-01-30T11:25:29.247Z","comments":true,"path":"2019/01/30/Centos下Nginx安装与配置/","link":"","permalink":"http://github.com/hzebin/2019/01/30/Centos下Nginx安装与配置/","excerpt":"","text":"Nginx有什么用？我们知道一个服务器只有一个80端口，如果我们有一个服务器，并且我们有多个web应用都需要使用到服务器的80端口，我们该怎么办呢？当第一个web应用使用了80端口后，其他应用就使用不了80端口，因为服务器的80端口已经被第一个web应用给占用了，为了解决多个应用在同一个服务器共同使用80端口，我们可以利用Nginx。 在Centos服务器下安装Nginx安装Nginx前的环境准备首先由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，这些依赖库主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel 所以执行如下命令安装 1234$ yum install gcc-c++ $ yum install pcre pcre-devel $ yum install zlib zlib-devel $ yum install openssl openssl--devel 开始安装Nginx安装之前，最好检查一下是否已经安装有nginx 1$ find -name nginx 如果系统已经安装了nginx，那么就先卸载 1$ yum remove nginx 首先进入/usr/local目录 1$ cd /usr/local 从官网下载最新版的nginx,可以进入官网寻找最新版本 1$ wget http://nginx.org/download/nginx-1.15.8.tar.gz 解压nginx压缩包 1$ tar -zxvf nginx-1.15.8.tar.gz 会产生一个nginx-1.15.8 目录，这时进入nginx-1.15.8目录 1$ cd nginx-1.15.8 接下来安装，使用–prefix参数指定nginx安装的目录,make、make install安装，命令如下：【如何系统提示./configure: error: the HTTP gzip module requires the zlib library. 则再安装库，命令为yum install -y zlib-devel】 123$ sudo ./configure --prefix=/usr/local/nginx #这一步需要按需要添加编译参数$ sudo make$ sudo make install 如果没有报错，顺利完成后，最好看一下nginx的安装目录 1$ whereis nginx 安装完毕后，进入安装后目录（/usr/local/nginx）便可以启动或停止它了。到此，使用CentOS安装nginx已经完成了! ## 启动 先测试一下配置文件是否正确： 1$ /usr/local/nginx/sbin/nginx -t 无问题可以启动：【如果使用netstat -ltunp命令，可以看到0.0.0.0:80端口被httpd这个进程占用了， 如何解决服务器的80端口被httpd占用，可以先让它httpd结束，命令为service httpd stop ； 启用httpd的命令为service httpd start】 1$ /usr/local/nginx/sbin/nginx 检查是否启动成功：打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。部分命令如下：重启： 1$ /usr/local/nginx/sbin/nginx –s reload 停止： 1$ /usr/local/nginx/sbin/nginx –s stop 测试配置文件是否正常： 1$ /usr/local/nginx/sbin/nginx –t 强制关闭： 1$ pkill nginx nginx.conf的配置我们可以在/usr/local/nginx/conf目录下找到nginx.conf文件，如下图 假设你的官网主页使用了80端口，它的url为http://xxx.cn ，另一个abc应用的url为http://abc.xxx.cn ,先在服务器建好文件夹准备存放不同的应用 12345678910111213141516171819202122232425262728293031323334353637worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; #使用80端口监听 server_name localhost; location / &#123; root /var/www/html/; #放官网的文件目录 index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; #使用80端口监听 server_name abc.xxx.cn; #abc web应用的url location / &#123; root /var/www/web_abc/; #存放abc web应用的文件夹 index index.html index.htm; proxy_pass http://120.55.123.123:1234; #假设服务器的ip地址为120.55.123.123，想用1234端口来转 #发,1234端口先设置服务器规则为允许 &#125; &#125; &#125; 现在在浏览器输入http://xxx.cn 就可以访问官网了，在浏览器输入http://abc.xxx.cn （子域名）就可以访问abc web应用了","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://github.com/hzebin/tags/服务器/"},{"name":"Centos","slug":"Centos","permalink":"http://github.com/hzebin/tags/Centos/"},{"name":"Nginx","slug":"Nginx","permalink":"http://github.com/hzebin/tags/Nginx/"}]},{"title":"利用python的turtle库绘画（随机花蕾）","slug":"利用python的turtle库绘画（随机花蕾）","date":"2019-01-25T06:44:38.000Z","updated":"2019-01-25T07:17:12.068Z","comments":true,"path":"2019/01/25/利用python的turtle库绘画（随机花蕾）/","link":"","permalink":"http://github.com/hzebin/2019/01/25/利用python的turtle库绘画（随机花蕾）/","excerpt":"","text":"使用python语言，利用turtle库绘画出了一个随机花蕾图，程序中使用了随机函数，所以每次运行结束展示的效果图都会不一样，图片展示： python源代码展示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import turtleimport randomturtle.tracer(100)def drawLine(drawColor,a,b,ra,rb): turtle.left(90) turtle.color(drawColor) turtle.pensize(1.8) turtle.circle(ra,a/2) turtle.pensize(1.6) turtle.circle(ra,a/2) turtle.pensize(1.4) turtle.circle(-rb,b/2) turtle.pensize(1.2) turtle.circle(-rb,b/2) turtle.penup() turtle.right(180) turtle.circle(rb,b) turtle.circle(-ra,a) turtle.left(180) turtle.pendown() turtle.right(90)def flower1(mySize,myLen,myColor): #花 六个花瓣 参数：画笔size 花瓣len 颜色color turtle.pensize(mySize) turtle.color(myColor) turtle.pendown() time=0 while time&lt;6: turtle.fd(myLen) turtle.left(120) turtle.fd(myLen) turtle.right(60) time+=1 turtle.penup()def rflower(left,s,rlena,rlenb,k,stepa,stepb): #画花的范围left 间隔s 花瓣大小 rCur 花间间隔stepa stepb while k&gt;left: turtle.right(90) turtle.fd(-k) k-=s turtle.fd(k) turtle.left(90) twoCircle=0 while twoCircle&lt;360: c=random.randint(0,1) if c: flower1(random.randint(2,5),random.randint(rlena,rlenb),\"#FF1493\") else: flower1(random.randint(2,5),random.randint(rlena,rlenb),\"#FFB6C1\") turtle.penup() step=random.randint(stepa,stepb) turtle.circle(k,step) twoCircle+=step return left-5 #turtle.setup(600,600)turtle.getscreen().bgcolor(\"black\")#turtle.speed(2000)turtle.penup()turtle.fd(250)turtle.left(90)'''#delect start..........turtle.pendown()turtle.color(\"#FFFFFF\")turtle.circle(250,360)turtle.penup()#delete end............'''turtle.pendown()# 深粉色 #FF1493# 浅粉红 #FFB6C1### 步骤1 ###oneCircle=0while oneCircle&lt;720: ra=random.randint(100,150) #曲线半径 a=random.randint(10,30) #曲线第一段的弧度 rb=random.randint(50,200) #曲线半径 b=random.randint(10,30) #曲线第二段的弧度 if oneCircle&lt;360: drawLine(\"#FF1493\",a,b,ra,rb) else: drawLine(\"#FFB6C1\",a,b,ra,rb) step=random.randint(3,7) turtle.penup() turtle.circle(250,step) turtle.pendown() oneCircle+=step### 步骤2 ###turtle.penup()k=245k=rflower(220,random.randint(10,20),1,3,k,3,20)k=rflower(150,random.randint(30,50),2,6,k,20,50)k=rflower(85,random.randint(50,70),5,15,k,50,100)turtle.update()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://github.com/hzebin/tags/python/"},{"name":"turtle库","slug":"turtle库","permalink":"http://github.com/hzebin/tags/turtle库/"}]},{"title":"利用python的turtle库绘画（卡通人物）","slug":"利用python的turtle库绘画（卡通人物）","date":"2019-01-25T06:34:01.000Z","updated":"2019-01-25T07:11:16.359Z","comments":true,"path":"2019/01/25/利用python的turtle库绘画（卡通人物）/","link":"","permalink":"http://github.com/hzebin/2019/01/25/利用python的turtle库绘画（卡通人物）/","excerpt":"","text":"使用python语言，利用turtle库绘画出了一个卡通人物图，图片展示： python源代码展示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534import turtleturtle.tracer(100)def init(): ##图画框的初始化 #turtle.setup(700, 700, 10, 0) turtle.pensize(8) turtle.seth(-90) turtle.penup() turtle.fd(250) turtle.seth(-180) # turtle.speed(100)def leftCloth(): ##人物左边的衣服 turtle.begin_fill() turtle.pendown() turtle.fd(30) # print(turtle.position()) #(-30.00,-250.00) turtle.right(10) turtle.fd(20) turtle.left(5) turtle.fd(40) turtle.right(40) turtle.fd(15) turtle.seth(85) turtle.fd(40) # print(turtle.position()) #(-96.66,-192.59) for i in range(10): turtle.fd(5) turtle.left(4) turtle.left(10) turtle.fd(150) # print(turtle.position()) #(-213.75,-38.78) turtle.right(90) turtle.fd(5) turtle.right(10) turtle.fd(5) turtle.left(10) turtle.fd(40) turtle.right(85) turtle.fd(110) for i in range(10): turtle.fd(3) turtle.left(3) turtle.fd(10) for i in range(10): turtle.fd(3) turtle.right(3) turtle.right(10) turtle.fd(20) turtle.right(20) for i in range(68): turtle.fd(2) turtle.right(0.3) turtle.fillcolor('#493830') turtle.end_fill() first = True ##衣服的两条不同颜色的折线 for j in range(2): turtle.penup() if first: turtle.goto(-30, -250) first = False else: turtle.goto(-40, -250) turtle.pencolor(\"#282320\") turtle.pensize(11) turtle.pendown() turtle.seth(100) turtle.fd(40) turtle.right(60) turtle.fd(30) turtle.left(90) turtle.fd(25) turtle.right(30) turtle.fd(50) for i in range(10): turtle.fd(3) turtle.left(2) turtle.pensize(8) # print(\"* 左衣间&#123;&#125;\".format(turtle.position())) turtle.pencolor(\"black\") # 左边衣服的两条褶皱 turtle.seth(-100) turtle.fd(20) turtle.penup() turtle.goto(-95, -170) turtle.pendown() turtle.seth(10) for i in range(10): turtle.fd(3) turtle.left(6)def palm(): # 人物的左手掌 turtle.begin_fill() turtle.penup() turtle.goto(-205, -30) turtle.pendown() turtle.seth(150) turtle.fd(20) for i in range(10): turtle.fd(3) turtle.right(5) for i in range(10): turtle.fd(1) turtle.right(5) for i in range(10): turtle.fd(2) turtle.right(3) turtle.right(20) turtle.fd(5) turtle.left(100) turtle.fd(10) turtle.right(90) turtle.fd(20) turtle.right(80) for i in range(20): turtle.fd(2) turtle.left(0.2) turtle.goto(-205, -30) turtle.fillcolor(\"#fdeab0\") turtle.end_fill()def neck(): # 人物的三角形脖子 turtle.penup() turtle.pencolor(\"black\") turtle.goto(-58, -85) turtle.seth(-10) turtle.pensize(5) turtle.pendown() turtle.begin_fill() for i in range(30): turtle.fd(3) turtle.left(0.6) turtle.seth(-60) turtle.fd(10) turtle.right(80) turtle.fd(30) # print(\"衣尖&#123;&#125;\".format(turtle.position())) turtle.right(60) turtle.fd(40) turtle.goto(-58, -85) turtle.fillcolor(\"#fdeab0\") turtle.end_fill()def collar(): # 人物中间的衬衫 turtle.goto(-30, -100) turtle.pencolor(\"black\") turtle.begin_fill() turtle.goto(-20, -120) turtle.goto(0, -180) turtle.goto(12, -250) turtle.seth(0) turtle.fd(60) turtle.seth(90) # print(\"衣服右下角&#123;&#125;\".format(turtle.position())) for i in range(53): turtle.fd(3) turtle.left(0.5) turtle.goto(13, -114) turtle.goto(-30, -100) turtle.fillcolor(\"#c1d2d6\") turtle.end_fill()def rightCloth(): # 人物右边的衣服 turtle.penup() turtle.goto(72, -250) turtle.seth(90) turtle.begin_fill() for i in range(58): turtle.fd(3) turtle.left(0.5) # print(\"右上衣尖&#123;&#125;\".format(turtle.position())) turtle.seth(-20) turtle.pendown() turtle.fd(20) for i in range(20): turtle.fd(2) turtle.right(2) turtle.fd(20) for i in range(30): turtle.fd(3) turtle.right(1) turtle.fd(10) turtle.right(30) turtle.fd(20) # print(\"右手间&#123;&#125;\".format(turtle.position())) turtle.goto(72, -250) turtle.fillcolor(\"#493830\") turtle.end_fill() first = True for j in range(2): # 右边衣服的两条不同颜色的折线 turtle.penup() if first: turtle.goto(102, -245) first = False else: turtle.goto(107, -245) turtle.pensize(5) turtle.pencolor(\"#282320\") turtle.pendown() turtle.seth(100) turtle.fd(40) turtle.left(30) turtle.fd(25) turtle.right(60) turtle.fd(30) turtle.left(60) turtle.fd(70)def face(): # 人物的脸部轮廓 turtle.penup() turtle.goto(29, -83) turtle.seth(0) turtle.pendown() turtle.begin_fill() for i in range(20): turtle.fd(6) turtle.left(2) for i in range(20): turtle.fd(2) turtle.left(4) for i in range(20): turtle.fd(2) turtle.right(2) # 头发位置开始 # print(\"头发开始位置&#123;&#125;\".format(turtle.position())) for i in range(20): turtle.fd(5) turtle.left(0.8) for i in range(10): turtle.fd(2) turtle.left(2) turtle.left(20) for i in range(50): turtle.fd(7) turtle.left(1.5) turtle.seth(-60) for i in range(40): turtle.fd(5) turtle.right(1.5) # 到达左手衣袖的上面 # print(\"左手&#123;&#125;\".format(turtle.position())) turtle.left(80) turtle.fd(115) for i in range(10): turtle.fd(5) turtle.left(4) turtle.left(10) turtle.fd(45) turtle.goto(29, -85) turtle.fillcolor(\"#fdeab0\") turtle.end_fill()def hair(): # 人物的头发 turtle.penup() turtle.goto(-181, -1) turtle.seth(50) turtle.pendown() turtle.begin_fill() for i in range(45): turtle.fd(4) turtle.left(1.6) turtle.seth(10) turtle.fd(100) turtle.right(5) turtle.fd(40) turtle.right(10) turtle.fd(80) for i in range(20): turtle.fd(1) turtle.right(1) turtle.fd(50) turtle.circle(-100, 10) for i in range(30): turtle.fd(1) turtle.right(2) turtle.fd(40) for i in range(20): turtle.fd(1) turtle.left(1) turtle.fd(20) turtle.left(180 - 40) turtle.fd(30) for i in range(10): turtle.fd(2) turtle.left(2) for i in range(30): turtle.fd(5) turtle.left(1.5) turtle.left(10) turtle.fd(10) turtle.right(180 - 60) turtle.fd(15) turtle.seth(145) turtle.fd(10) for i in range(10): turtle.fd(6) turtle.left(2) turtle.fd(50) turtle.left(10) turtle.fd(50) for i in range(30): turtle.fd(6) turtle.left(1.5) for i in range(10): turtle.fd(1) turtle.left(1) turtle.left(20) turtle.fd(20) turtle.right(10) for i in range(60): turtle.fd(2) turtle.left(1) turtle.goto(-181, -1) turtle.fillcolor(\"black\") turtle.end_fill()def eyebrow(): # 眉毛 turtle.penup() # 左眉毛 turtle.begin_fill() turtle.pensize(1) turtle.goto(-30, 100) turtle.pendown() turtle.seth(180 - 10) for i in range(20): turtle.fd(1.5) turtle.right(0.3) turtle.circle(-2, 165) turtle.fd(40) turtle.pensize(3) turtle.circle(-2, 200) turtle.goto(-30, 100) turtle.fillcolor(\"black\") turtle.end_fill() turtle.penup() # 右眉毛 turtle.begin_fill() turtle.pensize(1) turtle.seth(0) turtle.goto(50, 100) turtle.pendown() for i in range(20): turtle.fd(1.5) turtle.left(0.3) turtle.circle(2, 165) turtle.fd(40) turtle.pensize(3) turtle.circle(2, 200) turtle.goto(50, 100) turtle.fillcolor(\"black\") turtle.end_fill()def eyes(): # 眼睛 turtle.penup() turtle.begin_fill() # 右眼睛 turtle.goto(65, 80) turtle.seth(30) turtle.pensize(3) turtle.pendown() turtle.circle(-10, 30) for i in range(10): turtle.fd(3) turtle.right(8) turtle.right(20) turtle.fd(15) for i in range(20): turtle.fd(3) turtle.right(10) turtle.left(30) for i in range(10): f = turtle.fd(1.5) turtle.right(0.5) turtle.goto(65, 80) turtle.fillcolor(\"#884330\") turtle.end_fill() turtle.seth(-100) turtle.goto(70, 65) turtle.pencolor(\"black\") turtle.pensize(23) turtle.fd(15) turtle.penup() turtle.pencolor(\"#f9e3d1\") turtle.goto(75, 40) turtle.pendown() turtle.pensize(4) turtle.circle(2.8, 360) # 左眼睛 turtle.penup() turtle.begin_fill() turtle.goto(-50, 80) turtle.seth(30) turtle.pensize(3) turtle.pencolor(\"black\") turtle.pendown() turtle.circle(-10, 30) for i in range(10): turtle.fd(3) turtle.right(8) turtle.right(20) turtle.fd(15) for i in range(20): turtle.fd(3) turtle.right(10) turtle.left(30) for i in range(10): f = turtle.fd(1.5) turtle.right(0.5) turtle.goto(-50, 80) turtle.fillcolor(\"#884330\") turtle.end_fill() turtle.seth(-100) turtle.goto(-45, 65) turtle.pencolor(\"black\") turtle.pensize(23) turtle.fd(12) turtle.penup() turtle.pencolor(\"#f9e3d1\") turtle.goto(-37, 43) turtle.pendown() turtle.pensize(4) turtle.circle(2.8, 360)def redFace(): # 害羞的脸颊 mySize = 30 myLen = 40 first = True for j in range(2): turtle.penup() if first: # 左脸颊 turtle.pensize(mySize) turtle.pencolor(\"#f7bb84\") turtle.goto(-110, 0) first = False else: # 右脸颊 turtle.pencolor(\"#f7bb84\") turtle.seth(0) turtle.fd(140) mySize /= 1.1 myLen /= 1.3 turtle.pendown() turtle.seth(0) turtle.fd(myLen) turtle.penup() turtle.fd(-myLen + 5) for i in range(3): turtle.seth(-50) turtle.fd(-myLen / 4) turtle.pendown() turtle.pencolor(\"black\") turtle.pensize(mySize / 4) turtle.fd(myLen / 3) turtle.penup() turtle.fd(-2) turtle.seth(0) turtle.fd(14)def nose(): # 鼻子 turtle.penup() turtle.goto(10, 0) turtle.pensize(8) turtle.pencolor(\"#e6ce61\") turtle.pendown() for i in range(10): turtle.fd(2) turtle.fd(1)def mouse(): # 嘴巴 turtle.penup() turtle.goto(-10, -60) turtle.pencolor(\"black\") turtle.pendown() for i in range(20): turtle.fd(3) turtle.left(1)def signMyName(): # 签名 turtle.penup() turtle.goto(150, -200) turtle.pendown() turtle.write(\"黄泽彬\\n2018年10月28日\", font=(\"Arial\", 18, \"normal\"))def decoration(): # 手部摇动装饰 first = True for j in range(3): turtle.penup() if first: turtle.goto(-290, 10) first = False else: turtle.goto(-260, -10) turtle.pendown() turtle.seth(-85) for i in range(20): turtle.fd(4) turtle.left(2)def main(): ##主函数 init() ##初始化 leftCloth() ##左边的衣服 palm() # 左边手掌 neck() # 脖子 collar() # 中间的衬衫 rightCloth() # 右衣服 face() # 脸 hair() # 头发 eyebrow() # 眉毛 eyes() # 眼睛 redFace() # 红脸颊 nose() # 鼻子 mouse() # 嘴巴 signMyName() # 签名 decoration() # 手部摇动装饰main() # 主函数turtle.penup()turtle.hideturtle()turtle.update()turtle.done()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://github.com/hzebin/tags/python/"},{"name":"turtle库","slug":"turtle库","permalink":"http://github.com/hzebin/tags/turtle库/"}]},{"title":"test","slug":"test-author","date":"2019-01-20T07:25:54.000Z","updated":"2020-01-05T23:10:29.631Z","comments":true,"path":"2019/01/20/test-author/","link":"","permalink":"http://github.com/hzebin/2019/01/20/test-author/","excerpt":"","text":"@card{ 在page页中，建议把内容都放到card中。 } @timeline{ 2016@item{ 11月6日为 Card theme 添加 page layout。}}","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://github.com/hzebin/tags/test/"}]},{"title":"test","slug":"test","date":"2019-01-20T07:25:54.000Z","updated":"2019-01-25T07:20:17.104Z","comments":true,"path":"2019/01/20/test/","link":"","permalink":"http://github.com/hzebin/2019/01/20/test/","excerpt":"","text":"@card{ 在page页中，建议把内容都放到card中。 } @timeline{ 2016@item{ 11月6日为 Card theme 添加 page layout。}}","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://github.com/hzebin/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-20T07:24:37.142Z","updated":"2019-01-25T07:27:17.203Z","comments":true,"path":"2019/01/20/hello-world/","link":"","permalink":"http://github.com/hzebin/2019/01/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://github.com/hzebin/tags/test/"}]}]}